result - 98516383534690720
Wrote profile results to slippage_estimator.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: slippage_estimator.py
Function: get_output_token at line 341

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   341                                           @profile
   342                                           def get_output_token(_i: int, _j: int, _dx: int) -> int:
   343                                               num_tokens = pool.functions.numTokens().call()
   344                                               assert _i != _j  # dev: same input and output asset
   345                                               assert _i < num_tokens and _j < num_tokens  # dev: index out of bounds
   346                                               assert _dx > 0  # dev: zero amount
   347                                           
   348                                               # update rates for from and to assets
   349                                               supply = 0
   350                                               amplification = 0
   351                                               vb_prod = 0
   352                                               vb_sum = 0
   353                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   354                                               packed_weights = []
   355                                               rates = []
   356                                               supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   357                                                   unsafe_add(_i, 1) | (unsafe_add(_j, 1) << 8), vb_prod, vb_sum)
   358                                               prev_vb_sum = vb_sum
   359                                           
   360                                               prev_vb_x = pool.functions.virtualBalance(
   361                                                   _i).call() * rates[0] / pool.functions.rate(_i).call()
   362                                               wn_x = _unpack_wn(packed_weights[_i], num_tokens)
   363                                           
   364                                               prev_vb_y = pool.functions.virtualBalance(
   365                                                   _j).call() * rates[1] / pool.functions.rate(_j).call()
   366                                               wn_y = _unpack_wn(packed_weights[_j], num_tokens)
   367                                           
   368                                               dx_fee = _dx * pool.functions.swapFeeRate().call() / PRECISION
   369                                               dvb_x = (_dx - dx_fee) * rates[0] / PRECISION
   370                                               vb_x = prev_vb_x + dvb_x
   371                                           
   372                                               # update x_i and remove x_j from variables
   373                                               vb_prod = vb_prod * math._pow_up(int(prev_vb_y), (wn_y)) / \
   374                                                   math._pow_down(int(vb_x * PRECISION // prev_vb_x), int(wn_x))
   375                                               vb_sum = vb_sum + dvb_x - prev_vb_y
   376                                           
   377                                               # calulate new balance of out token
   378                                               vb_y = _calc_vb(int(wn_y), int(prev_vb_y), int(supply),
   379                                                               int(amplification), int(vb_prod), int(vb_sum))
   380                                               vb_sum += vb_y + dx_fee * rates[0] // PRECISION
   381                                           
   382                                               # check bands
   383                                               _check_bands(prev_vb_x * PRECISION // prev_vb_sum,
   384                                                            vb_x * PRECISION // vb_sum, packed_weights[_i])
   385                                               _check_bands(prev_vb_y * PRECISION // prev_vb_sum,
   386                                                            vb_y * PRECISION // vb_sum, packed_weights[_j])
   387                                           
   388                                               return (prev_vb_y - vb_y) * PRECISION / rates[1]

Total time: 16.2704 s
File: slippage_estimator.py
Function: get_add_lp at line 391

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   391                                           @profile
   392                                           def get_add_lp(_amounts: List[int]) -> int:
   393         1          1.0      1.0      0.0      num_tokens = 4
   394         1          2.0      2.0      0.0      assert len(_amounts) == num_tokens
   395                                           
   396         1          1.0      1.0      0.0      vb_prod = 0
   397         1          0.0      0.0      0.0      vb_sum = 0
   398         1     710889.0 710889.0      4.4      (vb_prod, vb_sum) = pool.functions.virtualBalanceProdSum().call()
   399         1          0.0      0.0      0.0      assert vb_sum > 0
   400                                           
   401                                               # find lowest relative increase in balance
   402         1          0.0      0.0      0.0      tokens = 0
   403         1          4.0      4.0      0.0      lowest = 2**256 - 1
   404         1          0.0      0.0      0.0      sh = 0
   405         5          5.0      1.0      0.0      for token in range(MAX_NUM_ASSETS):
   406         5          2.0      0.4      0.0          if token == num_tokens:
   407         1          0.0      0.0      0.0              break
   408         4          1.0      0.2      0.0          if _amounts[token] > 0:
   409         1          4.0      4.0      0.0              tokens = tokens | (unsafe_add(token, 1) << sh)
   410         1          1.0      1.0      0.0              sh = unsafe_add(sh, 8)
   411         1          1.0      1.0      0.0              if vb_sum > 0 and lowest > 0:
   412         3     729308.0 243102.7      4.5                  lowest = min(_amounts[token] * pool.functions.rate(token).call() /
   413         2    1110845.0 555422.5      6.8                               pool.functions.virtualBalance(token).call(), lowest)
   414                                                   else:
   415         3          1.0      0.3      0.0              lowest = 0
   416         1          1.0      1.0      0.0      assert (sh > 0)
   417                                           
   418                                               # update rates
   419         1          0.0      0.0      0.0      prev_supply = 0
   420         1          0.0      0.0      0.0      amplification = 0
   421         1          0.0      0.0      0.0      packed_weights = []
   422         1          0.0      0.0      0.0      rates = []
   423                                           
   424         2   10072767.0    5e+06     61.9      prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   425         1          0.0      0.0      0.0          tokens, vb_prod, vb_sum)
   426                                           
   427         1          0.0      0.0      0.0      vb_prod_final = vb_prod
   428         1          1.0      1.0      0.0      vb_sum_final = vb_sum
   429         1     722474.0 722474.0      4.4      fee_rate = pool.functions.swapFeeRate().call() / 2
   430         1          1.0      1.0      0.0      prev_vb_sum = vb_sum
   431         1          0.0      0.0      0.0      balances = []
   432         1          0.0      0.0      0.0      j = 0
   433         5          6.0      1.2      0.0      for token in range(MAX_NUM_ASSETS):
   434         5          2.0      0.4      0.0          if token == num_tokens:
   435         1          1.0      1.0      0.0              break
   436                                           
   437         4          2.0      0.5      0.0          amount = _amounts[token]
   438         4          4.0      1.0      0.0          if amount == 0:
   439         3          2.0      0.7      0.0              continue
   440                                           
   441         4        558.0    139.5      0.0          prev_vb = pool.functions.virtualBalance(
   442         3    1464761.0 488253.7      9.0              token).call() * rates[j] / pool.functions.rate(token).call()
   443                                           
   444         1          4.0      4.0      0.0          dvb = amount * rates[j] / PRECISION
   445         1          0.0      0.0      0.0          vb = prev_vb + dvb
   446         1          4.0      4.0      0.0          balances.append(vb)
   447                                           
   448         1          1.0      1.0      0.0          if prev_supply > 0:
   449         1         26.0     26.0      0.0              wn = _unpack_wn(packed_weights[token], num_tokens)
   450                                           
   451                                                       # update product and sum of virtual balances
   452         3          2.0      0.7      0.0              vb_prod_final = vb_prod_final * \
   453         2        201.0    100.5      0.0                  math._pow_up(int(prev_vb * PRECISION / vb), wn) / PRECISION
   454                                                       # the `D^n` factor will be updated in `_calc_supply()`
   455         1          1.0      1.0      0.0              vb_sum_final += dvb
   456                                           
   457                                                       # remove fees from balance and recalculate sum and product
   458         4          4.0      1.0      0.0              fee = (dvb - prev_vb * lowest /
   459         3          1.0      0.3      0.0                     PRECISION) * fee_rate / PRECISION
   460         3          3.0      1.0      0.0              vb_prod = vb_prod * \
   461         3        167.0     55.7      0.0                  math._pow_up(int(prev_vb * PRECISION /
   462         3          0.0      0.0      0.0                               (vb - fee)), wn) / PRECISION
   463         1          1.0      1.0      0.0              vb_sum += dvb - fee
   464         1          3.0      3.0      0.0          j = unsafe_add(j, 1)
   465                                           
   466                                               #  check bands
   467         1          1.0      1.0      0.0      j = 0
   468         5          4.0      0.8      0.0      for token in range(MAX_NUM_ASSETS):
   469         5          3.0      0.6      0.0          if token == num_tokens:
   470         1          1.0      1.0      0.0              break
   471         4          2.0      0.5      0.0          if _amounts[token] == 0:
   472         3          2.0      0.7      0.0              continue
   473         6     727356.0 121226.0      4.5          _check_bands(pool.functions.virtualBalance(token).call() * rates[j] / pool.functions.rate(
   474         5     730619.0 146123.8      4.5              token).call() * PRECISION / prev_vb_sum, balances[j] * PRECISION / vb_sum_final, packed_weights[token])
   475         1          2.0      2.0      0.0          j = unsafe_add(j, 1)
   476                                           
   477         1          0.0      0.0      0.0      supply = 0
   478         2        325.0    162.5      0.0      (supply, vb_prod) = _calc_supply(int(num_tokens), int(prev_supply),
   479         1          1.0      1.0      0.0                                       int(amplification), int(vb_prod), int(vb_sum), prev_supply == 0)
   480         1          0.0      0.0      0.0      return supply - prev_supply

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_lp at line 483

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   483                                           @profile
   484                                           def get_remove_lp(_lp_amount: int) -> List[int]:
   485                                               amounts = []
   486                                               num_tokens = pool.functions.numTokens().call()
   487                                               prev_supply = pool.functions.supply().call()
   488                                           
   489                                               assert (_lp_amount <= prev_supply)
   490                                           
   491                                               for token in range(MAX_NUM_ASSETS):
   492                                                   if token == num_tokens:
   493                                                       break
   494                                                   prev_bal = pool.functions.virtualBalance(token).call()
   495                                                   dbal = prev_bal * _lp_amount // prev_supply
   496                                                   amount = dbal * PRECISION // pool.functions.rate(token).call()
   497                                                   amounts.append(amount)
   498                                           
   499                                               return amounts

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_single_lp at line 502

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   502                                           @profile
   503                                           def get_remove_single_lp(_token: int, _lp_amount: int) -> int:
   504                                               num_tokens = pool.functions.numTokens().call()
   505                                               assert _token < num_tokens
   506                                           
   507                                               #  update rate
   508                                               prev_supply = 0
   509                                               amplification = 0
   510                                               vb_prod = 0
   511                                               vb_sum = 0
   512                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   513                                               packed_weights = []
   514                                               rates = []
   515                                               prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   516                                                   unsafe_add(_token, 1), vb_prod, vb_sum)
   517                                               prev_vb_sum = vb_sum
   518                                           
   519                                               supply = prev_supply - _lp_amount
   520                                               prev_vb = pool.functions.virtualBalance(_token).call(
   521                                               ) * rates[0] / pool.functions.rate(_token).call()
   522                                               wn = _unpack_wn(packed_weights[_token], num_tokens)
   523                                           
   524                                               #  update variables
   525                                               vb_prod = vb_prod * math._pow_up(int(prev_vb), int(wn)) / PRECISION
   526                                               for i in range(MAX_NUM_ASSETS):
   527                                                   if i == num_tokens:
   528                                                       break
   529                                                   vb_prod = vb_prod * supply / prev_supply
   530                                               vb_sum = vb_sum - prev_vb
   531                                           
   532                                               #  calculate new balance of token
   533                                               vb = _calc_vb(int(wn), int(prev_vb), int(supply), int(
   534                                                   amplification), int(vb_prod), int(vb_sum))
   535                                               dvb = prev_vb - vb
   536                                               fee = int(dvb) * pool.functions.swapFeeRate().call() // 2 // PRECISION
   537                                               dvb -= fee
   538                                               vb += fee
   539                                               dx = dvb * PRECISION / rates[0]
   540                                               vb_sum = vb_sum + vb
   541                                           
   542                                               for token in range(MAX_NUM_ASSETS):
   543                                                   if token == num_tokens:
   544                                                       break
   545                                                   if token == _token:
   546                                                       _check_bands(prev_vb * PRECISION // prev_vb_sum, vb *
   547                                                                    PRECISION // vb_sum, packed_weights[token])
   548                                                   else:
   549                                                       bal = pool.functions.virtualBalance(token).call()
   550                                                       _check_bands(bal * PRECISION / prev_vb_sum, bal *
   551                                                                    PRECISION // vb_sum, packed_weights[token])
   552                                           
   553                                               return dx

Total time: 10.0726 s
File: slippage_estimator.py
Function: _get_rates at line 556

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   556                                           @profile
   557                                           def _get_rates(_tokens: int, _vb_prod: int, _vb_sum: int) -> (int, int, int, int, List[int], List[int]):
   558         1          1.0      1.0      0.0      packed_weights = []
   559         1          1.0      1.0      0.0      rates = []
   560                                           
   561         1          1.0      1.0      0.0      amplification = 0
   562         1          0.0      0.0      0.0      vb_prod = 0
   563         1          0.0      0.0      0.0      vb_sum = _vb_sum
   564         2    2447325.0    1e+06     24.3      amplification, vb_prod, _packed_weights, updated = _get_packed_weights(
   565         1          0.0      0.0      0.0          _vb_prod, _vb_sum)
   566                                           
   567         1     714063.0 714063.0      7.1      num_tokens = pool.functions.numTokens().call()
   568                                           
   569         1          1.0      1.0      0.0      if not updated:
   570         5         12.0      2.4      0.0          for token in range(MAX_NUM_ASSETS):
   571         5          3.0      0.6      0.0              if token == num_tokens:
   572         1          0.0      0.0      0.0                  break
   573         4    2890267.0 722566.8     28.7              packed_weights.append(pool.functions.packedWeight(token).call())
   574                                           
   575         2          3.0      1.5      0.0      for i in range(MAX_NUM_ASSETS):
   576         2         10.0      5.0      0.0          token = (_tokens >> unsafe_mul(8, i)) & 255
   577         2          0.0      0.0      0.0          if token == 0 or token > num_tokens:
   578         1          1.0      1.0      0.0              break
   579         1          1.0      1.0      0.0          token = unsafe_sub(token, 1)
   580         1     716645.0 716645.0      7.1          prev_rate = pool.functions.rate(token).call()
   581                                           
   582         1    1133731.0    1e+06     11.3          provider_address = pool.functions.rateProviders(token).call()
   583         2      11823.0   5911.5      0.1          provider = web3.eth.contract(
   584         1          1.0      1.0      0.0              address=provider_address, abi=rate_provider_abi)
   585         3        524.0    174.7      0.0          rate = provider.functions.rate(
   586         2    1442496.0 721248.0     14.3              pool.functions.tokens(token).call()).call()
   587         1          1.0      1.0      0.0          assert rate > 0
   588         1          1.0      1.0      0.0          rates.append(rate)
   589                                           
   590         1          1.0      1.0      0.0          if rate == prev_rate:
   591         1          1.0      1.0      0.0              continue
   592                                           
   593                                                   if prev_rate > 0 and vb_sum > 0:
   594                                                       # factor out old rate and factor in new
   595                                                       wn = _unpack_wn(packed_weights[token], num_tokens)
   596                                                       vb_prod = vb_prod * \
   597                                                           math._pow_up(int(prev_rate * PRECISION // rate),
   598                                                                        wn) / PRECISION
   599                                           
   600                                                       prev_bal = pool.functions.virtualBalance(token).call()
   601                                                       bal = prev_bal * rate // prev_rate
   602                                                       vb_sum = vb_sum + bal - prev_bal
   603                                           
   604         1          1.0      1.0      0.0      if not updated and vb_prod == _vb_prod and vb_sum == _vb_sum:
   605         1     715720.0 715720.0      7.1          return pool.functions.supply().call(), amplification, vb_prod, vb_sum, packed_weights, rates
   606                                           
   607                                               supply = 0
   608                                               (supply, vb_prod) = _calc_supply(int(num_tokens),
   609                                                                                int(pool.functions.supply().call()), int(amplification), int(vb_prod), int(vb_sum), True)
   610                                               return supply, amplification, vb_prod, vb_sum, packed_weights, rates

Total time: 2.44724 s
File: slippage_estimator.py
Function: _get_packed_weights at line 613

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   613                                           @profile
   614                                           def _get_packed_weights(_vb_prod: int, _vb_sum: int) -> (int, int, List[int], bool):
   615         1          1.0      1.0      0.0      packed_weights = []
   616         1     729681.0 729681.0     29.8      span = pool.functions.rampLastTime().call()
   617         1     723211.0 723211.0     29.6      duration = pool.functions.rampStopTime().call()
   618                                           
   619         1     267856.0 267856.0     10.9      block = web3.eth.get_block('latest')
   620         1          1.0      1.0      0.0      timestamp = block['timestamp']
   621         1          1.0      1.0      0.0      if span == 0 or span > timestamp or (block.timestamp - span < pool.functions.rampStep().call() and duration > timestamp):
   622         1     726485.0 726485.0     29.7          return pool.functions.amplification().call(), _vb_prod, packed_weights, False
   623                                           
   624                                               if timestamp < duration:
   625                                                   # ramp in progress
   626                                                   duration -= span
   627                                               else:
   628                                                   #  ramp has finished
   629                                                   duration = 0
   630                                               span = timestamp - span
   631                                           
   632                                               #  update amplification
   633                                               current = pool.functions.amplification().call()
   634                                               target = pool.functions.targetAmplification().call()
   635                                           
   636                                               if duration == 0:
   637                                                   current = target
   638                                               else:
   639                                                   if current > target:
   640                                                       current = current - (current - target) * span / duration
   641                                                   else:
   642                                                       current = current + (target - current) * span / duration
   643                                               amplification = current
   644                                           
   645                                               #  update weights
   646                                               num_tokens = pool.functions.numTokens.call()
   647                                               supply = pool.functions.supply().call()
   648                                               vb_prod = 0
   649                                               if _vb_sum > 0:
   650                                                   vb_prod = PRECISION
   651                                               lower = 0
   652                                               upper = 0
   653                                               for token in range(MAX_NUM_ASSETS):
   654                                                   if token == num_tokens:
   655                                                       break
   656                                                   current, target, lower, upper = pool.functions.weight(token).call()
   657                                                   if duration == 0:
   658                                                       current = target
   659                                                   else:
   660                                                       if current > target:
   661                                                           current -= (current - target) * span / duration
   662                                                       else:
   663                                                           current += (target - current) * span / duration
   664                                                   packed_weights.append(_pack_weight(current, target, lower, upper))
   665                                                   if _vb_sum > 0:
   666                                                       vb_prod = unsafe_div(unsafe_mul(vb_prod, math._pow_down(unsafe_div(unsafe_mul(
   667                                                           supply, current), pool.functions.virtualBalance(token)), unsafe_mul(current, num_tokens))), PRECISION)
   668                                           
   669                                               return amplification, vb_prod, packed_weights, True

Total time: 0 s
File: slippage_estimator.py
Function: _pack_weight at line 672

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   672                                           @profile
   673                                           def _pack_weight(_weight: int, _target: int, _lower: int, _upper: int) -> int:
   674                                               return unsafe_div(_weight, WEIGHT_SCALE) | (unsafe_div(_target, WEIGHT_SCALE) << -TARGET_WEIGHT_SHIFT) | (unsafe_div(_lower, WEIGHT_SCALE) << -LOWER_BAND_SHIFT) | (unsafe_div(_upper, WEIGHT_SCALE) << -UPPER_BAND_SHIFT)

Total time: 0 s
File: slippage_estimator.py
Function: _unpack_weights at line 677

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   677                                           @profile
   678                                           def _unpack_weights(_packed: int) -> (int, int, int, int):
   679                                               return unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -TARGET_WEIGHT_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)

Total time: 7e-06 s
File: slippage_estimator.py
Function: _unpack_wn at line 682

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   682                                           @profile
   683                                           def _unpack_wn(_packed: int, _num_tokens: int) -> int:
   684         1          7.0      7.0    100.0      return unsafe_mul(unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), _num_tokens)

Total time: 0.000188 s
File: slippage_estimator.py
Function: _calc_supply at line 687

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   687                                           @profile
   688                                           def _calc_supply(_num_tokens: int, _supply: int, _amplification: int, _vb_prod: int, _vb_sum: int, _up: bool) -> (int, int):
   689                                               # s[n+1] = (A sum / w^n - s^(n+1) w^n /prod^n)) / (A w^n - 1)
   690                                               #        = (l - s r) / d
   691                                           
   692         1          1.0      1.0      0.5      l = _amplification
   693         1          1.0      1.0      0.5      d = l - PRECISION
   694         1          1.0      1.0      0.5      s = _supply
   695         1          0.0      0.0      0.0      r = _vb_prod
   696         1          1.0      1.0      0.5      l = l * _vb_sum
   697                                           
   698         1          0.0      0.0      0.0      num_tokens = _num_tokens
   699        15          7.0      0.5      3.7      for _ in range(255):
   700        45         22.0      0.5     11.7          sp = unsafe_div(unsafe_sub(
   701        30         12.0      0.4      6.4              l, unsafe_mul(s, r)), d)  # (l - s * r) / d
   702        75         22.0      0.3     11.7          for i in range(MAX_NUM_ASSETS):
   703        75         10.0      0.1      5.3              if i == num_tokens:
   704        15          5.0      0.3      2.7                  break
   705        60         77.0      1.3     41.0              r = unsafe_div(unsafe_mul(r, sp), s)  # r * sp / s
   706        15          4.0      0.3      2.1          if sp >= s:
   707         8          7.0      0.9      3.7              if (sp - s) * PRECISION / s <= MAX_POW_REL_ERR:
   708         1          0.0      0.0      0.0                  if _up:
   709                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   710                                                           else:
   711         1          2.0      2.0      1.1                      sp -= sp * MAX_POW_REL_ERR / PRECISION
   712         1          0.0      0.0      0.0                  return sp, r
   713                                                   else:
   714         7          7.0      1.0      3.7              if (s - sp) * PRECISION / s <= MAX_POW_REL_ERR:
   715                                                           if _up:
   716                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   717                                                           else:
   718                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   719                                                           return sp, r
   720        14          9.0      0.6      4.8          s = sp
   721                                           
   722                                               raise "no convergence"

Total time: 0 s
File: slippage_estimator.py
Function: _calc_vb at line 725

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   725                                           @profile
   726                                           def _calc_vb(_wn, _y, _supply, _amplification, _vb_prod, _vb_sum) -> int:
   727                                               # y = x_j, sum' = sum(x_i, i != j), prod' = prod(x_i^w_i, i != j)
   728                                               # w = product(w_i), v_i = w_i n, f_i = 1/v_i
   729                                               # Iteratively find root of g(y) using Newton's method
   730                                               # g(y) = y^(v_j + 1) + (sum' + (w^n / A - 1) D y^(w_j n) - D^(n+1) w^2n / prod'^n
   731                                               #      = y^(v_j + 1) + b y^(v_j) - c
   732                                               # y[n+1] = y[n] - g(y[n])/g'(y[n])
   733                                               #        = (y[n]^2 + b (1 - f_j) y[n] + c f_j y[n]^(1 - v_j)) / (f_j + 1) y[n] + b)
   734                                           
   735                                               d = _supply
   736                                               b = d * PRECISION // _amplification  # actually b + D
   737                                               c = _vb_prod * b // PRECISION
   738                                               b += _vb_sum
   739                                               f = PRECISION * PRECISION // _wn
   740                                           
   741                                               y = _y
   742                                               for _ in range(255):
   743                                                   yp = (y + b + d * f // PRECISION + c * f // math._pow_up(int(y), int(_wn)) -
   744                                                         b * f // PRECISION - d) * y // (f * y // PRECISION + y + b - d)
   745                                                   if yp >= y:
   746                                                       if (yp - y) * PRECISION // y <= MAX_POW_REL_ERR:
   747                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   748                                                           return yp
   749                                                   else:
   750                                                       if (y - yp) * PRECISION // y <= MAX_POW_REL_ERR:
   751                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   752                                                           return yp
   753                                                   y = yp
   754                                           
   755                                               raise "no convergence"

Total time: 1.4e-05 s
File: slippage_estimator.py
Function: _check_bands at line 758

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   758                                           @profile
   759                                           def _check_bands(_prev_ratio, _ratio, _packed_weight):
   760         1          3.0      3.0     21.4      weight = unsafe_mul(_packed_weight & WEIGHT_MASK, WEIGHT_SCALE)
   761                                           
   762                                               # lower limit check
   763         2          1.0      0.5      7.1      limit = unsafe_mul(
   764         1          2.0      2.0     14.3          (_packed_weight >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE)
   765         1          0.0      0.0      0.0      if limit > weight:
   766         1          1.0      1.0      7.1          limit = 0
   767                                               else:
   768                                                   limit = unsafe_sub(weight, limit)
   769         1          1.0      1.0      7.1      if _ratio < limit:
   770                                                   assert _ratio > _prev_ratio  # dev: ratio below lower band
   771                                           
   772                                               # upper limit check
   773         3          4.0      1.3     28.6      limit = min(unsafe_add(weight, unsafe_mul(
   774         2          1.0      0.5      7.1          (_packed_weight >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)), PRECISION)
   775         1          1.0      1.0      7.1      if _ratio > limit:
   776                                                   assert _ratio < _prev_ratio  # dev: ratio above upper band

