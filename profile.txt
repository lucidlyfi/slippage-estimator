Wrote profile results to slippage_estimator.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: slippage_estimator.py
Function: get_output_token at line 334

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   334                                           @profile
   335                                           def get_output_token(_i: int, _j: int, _dx: int) -> int:
   336                                               num_tokens = pool.functions.numTokens().call()
   337                                               assert _i != _j  # dev: same input and output asset
   338                                               assert _i < num_tokens and _j < num_tokens  # dev: index out of bounds
   339                                               assert _dx > 0  # dev: zero amount
   340                                           
   341                                               # update rates for from and to assets
   342                                               supply = 0
   343                                               amplification = 0
   344                                               vb_prod = 0
   345                                               vb_sum = 0
   346                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   347                                               packed_weights = []
   348                                               rates = []
   349                                               supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   350                                                   unsafe_add(_i, 1) | (unsafe_add(_j, 1) << 8), vb_prod, vb_sum)
   351                                               prev_vb_sum = vb_sum
   352                                           
   353                                               prev_vb_x = pool.functions.virtualBalance(
   354                                                   _i).call() * rates[0] / pool.functions.rate(_i).call()
   355                                               wn_x = _unpack_wn(packed_weights[_i], num_tokens)
   356                                           
   357                                               prev_vb_y = pool.functions.virtualBalance(
   358                                                   _j).call() * rates[1] / pool.functions.rate(_j).call()
   359                                               wn_y = _unpack_wn(packed_weights[_j], num_tokens)
   360                                           
   361                                               dx_fee = _dx * pool.functions.swapFeeRate().call() / PRECISION
   362                                               dvb_x = (_dx - dx_fee) * rates[0] / PRECISION
   363                                               vb_x = prev_vb_x + dvb_x
   364                                           
   365                                               # update x_i and remove x_j from variables
   366                                               vb_prod = vb_prod * math._pow_up(int(prev_vb_y), (wn_y)) / \
   367                                                   math._pow_down(int(vb_x * PRECISION // prev_vb_x), int(wn_x))
   368                                               vb_sum = vb_sum + dvb_x - prev_vb_y
   369                                           
   370                                               # calulate new balance of out token
   371                                               vb_y = _calc_vb(int(wn_y), int(prev_vb_y), int(supply),
   372                                                               int(amplification), int(vb_prod), int(vb_sum))
   373                                               vb_sum += vb_y + dx_fee * rates[0] // PRECISION
   374                                           
   375                                               # check bands
   376                                               _check_bands(prev_vb_x * PRECISION // prev_vb_sum,
   377                                                            vb_x * PRECISION // vb_sum, packed_weights[_i])
   378                                               _check_bands(prev_vb_y * PRECISION // prev_vb_sum,
   379                                                            vb_y * PRECISION // vb_sum, packed_weights[_j])
   380                                           
   381                                               return (prev_vb_y - vb_y) * PRECISION / rates[1]

Total time: 0 s
File: slippage_estimator.py
Function: get_add_lp at line 384

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   384                                           @profile
   385                                           def get_add_lp(_amounts: List[int]) -> int:
   386                                               num_tokens = pool.functions.numTokens().call()
   387                                               assert len(_amounts) == num_tokens
   388                                           
   389                                               vb_prod = 0
   390                                               vb_sum = 0
   391                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   392                                               assert vb_sum > 0
   393                                           
   394                                               # find lowest relative increase in balance
   395                                               tokens = 0
   396                                               lowest = 2**256 - 1
   397                                               sh = 0
   398                                               for token in range(MAX_NUM_ASSETS):
   399                                                   if token == num_tokens:
   400                                                       break
   401                                                   if _amounts[token] > 0:
   402                                                       tokens = tokens | (unsafe_add(token, 1) << sh)
   403                                                       sh = unsafe_add(sh, 8)
   404                                                       if vb_sum > 0 and lowest > 0:
   405                                                           lowest = min(_amounts[token] * pool.functions.rate(token).call() /
   406                                                                        pool.functions.virtualBalance(token).call(), lowest)
   407                                                   else:
   408                                                       lowest = 0
   409                                               assert (sh > 0)
   410                                           
   411                                               # update rates
   412                                               prev_supply = 0
   413                                               amplification = 0
   414                                               packed_weights = []
   415                                               rates = []
   416                                           
   417                                               prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   418                                                   tokens, vb_prod, vb_sum)
   419                                           
   420                                               vb_prod_final = vb_prod
   421                                               vb_sum_final = vb_sum
   422                                               fee_rate = pool.functions.swapFeeRate().call() / 2
   423                                               prev_vb_sum = vb_sum
   424                                               balances = []
   425                                               j = 0
   426                                               for token in range(MAX_NUM_ASSETS):
   427                                                   if token == num_tokens:
   428                                                       break
   429                                           
   430                                                   amount = _amounts[token]
   431                                                   if amount == 0:
   432                                                       continue
   433                                           
   434                                                   prev_vb = pool.functions.virtualBalance(
   435                                                       token).call() * rates[j] / pool.functions.rate(token).call()
   436                                           
   437                                                   dvb = amount * rates[j] / PRECISION
   438                                                   vb = prev_vb + dvb
   439                                                   balances.append(vb)
   440                                           
   441                                                   if prev_supply > 0:
   442                                                       wn = _unpack_wn(packed_weights[token], num_tokens)
   443                                           
   444                                                       # update product and sum of virtual balances
   445                                                       vb_prod_final = vb_prod_final * \
   446                                                           math._pow_up(int(prev_vb * PRECISION / vb), wn) / PRECISION
   447                                                       # the `D^n` factor will be updated in `_calc_supply()`
   448                                                       vb_sum_final += dvb
   449                                           
   450                                                       # remove fees from balance and recalculate sum and product
   451                                                       fee = (dvb - prev_vb * lowest /
   452                                                              PRECISION) * fee_rate / PRECISION
   453                                                       vb_prod = vb_prod * \
   454                                                           math._pow_up(int(prev_vb * PRECISION /
   455                                                                        (vb - fee)), wn) / PRECISION
   456                                                       vb_sum += dvb - fee
   457                                                   j = unsafe_add(j, 1)
   458                                           
   459                                               #  check bands
   460                                               j = 0
   461                                               for token in range(MAX_NUM_ASSETS):
   462                                                   if token == num_tokens:
   463                                                       break
   464                                                   if _amounts[token] == 0:
   465                                                       continue
   466                                                   _check_bands(pool.functions.virtualBalance(token).call() * rates[j] / pool.functions.rate(
   467                                                       token).call() * PRECISION / prev_vb_sum, balances[j] * PRECISION / vb_sum_final, packed_weights[token])
   468                                                   j = unsafe_add(j, 1)
   469                                           
   470                                               supply = 0
   471                                               (supply, vb_prod) = _calc_supply(int(num_tokens), int(prev_supply),
   472                                                                                int(amplification), int(vb_prod), int(vb_sum), prev_supply == 0)
   473                                               return supply - prev_supply

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_lp at line 476

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   476                                           @profile
   477                                           def get_remove_lp(_lp_amount: int) -> List[int]:
   478                                               amounts = []
   479                                               num_tokens = pool.functions.numTokens().call()
   480                                               prev_supply = pool.functions.supply().call()
   481                                           
   482                                               assert (_lp_amount <= prev_supply)
   483                                           
   484                                               for token in range(MAX_NUM_ASSETS):
   485                                                   if token == num_tokens:
   486                                                       break
   487                                                   prev_bal = pool.functions.virtualBalance(token).call()
   488                                                   dbal = prev_bal * _lp_amount // prev_supply
   489                                                   amount = dbal * PRECISION // pool.functions.rate(token).call()
   490                                                   amounts.append(amount)
   491                                           
   492                                               return amounts

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_single_lp at line 495

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   495                                           @profile
   496                                           def get_remove_single_lp(_token: int, _lp_amount: int) -> int:
   497                                               num_tokens = pool.functions.numTokens().call()
   498                                               assert _token < num_tokens
   499                                           
   500                                               #  update rate
   501                                               prev_supply = 0
   502                                               amplification = 0
   503                                               vb_prod = 0
   504                                               vb_sum = 0
   505                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   506                                               packed_weights = []
   507                                               rates = []
   508                                               prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   509                                                   unsafe_add(_token, 1), vb_prod, vb_sum)
   510                                               prev_vb_sum = vb_sum
   511                                           
   512                                               supply = prev_supply - _lp_amount
   513                                               prev_vb = pool.functions.virtualBalance(_token).call(
   514                                               ) * rates[0] / pool.functions.rate(_token).call()
   515                                               wn = _unpack_wn(packed_weights[_token], num_tokens)
   516                                           
   517                                               #  update variables
   518                                               vb_prod = vb_prod * math._pow_up(int(prev_vb), int(wn)) / PRECISION
   519                                               for i in range(MAX_NUM_ASSETS):
   520                                                   if i == num_tokens:
   521                                                       break
   522                                                   vb_prod = vb_prod * supply / prev_supply
   523                                               vb_sum = vb_sum - prev_vb
   524                                           
   525                                               #  calculate new balance of token
   526                                               vb = _calc_vb(int(wn), int(prev_vb), int(supply), int(
   527                                                   amplification), int(vb_prod), int(vb_sum))
   528                                               dvb = prev_vb - vb
   529                                               fee = int(dvb) * pool.functions.swapFeeRate().call() // 2 // PRECISION
   530                                               dvb -= fee
   531                                               vb += fee
   532                                               dx = dvb * PRECISION / rates[0]
   533                                               vb_sum = vb_sum + vb
   534                                           
   535                                               for token in range(MAX_NUM_ASSETS):
   536                                                   if token == num_tokens:
   537                                                       break
   538                                                   if token == _token:
   539                                                       _check_bands(prev_vb * PRECISION // prev_vb_sum, vb *
   540                                                                    PRECISION // vb_sum, packed_weights[token])
   541                                                   else:
   542                                                       bal = pool.functions.virtualBalance(token).call()
   543                                                       _check_bands(bal * PRECISION / prev_vb_sum, bal *
   544                                                                    PRECISION // vb_sum, packed_weights[token])
   545                                           
   546                                               return dx

Total time: 0 s
File: slippage_estimator.py
Function: _get_rates at line 549

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   549                                           @profile
   550                                           def _get_rates(_tokens: int, _vb_prod: int, _vb_sum: int) -> (int, int, int, int, List[int], List[int]):
   551                                               packed_weights = []
   552                                               rates = []
   553                                           
   554                                               amplification = 0
   555                                               vb_prod = 0
   556                                               vb_sum = _vb_sum
   557                                               amplification, vb_prod, _packed_weights, updated = _get_packed_weights(
   558                                                   _vb_prod, _vb_sum)
   559                                           
   560                                               num_tokens = pool.functions.numTokens().call()
   561                                           
   562                                               if not updated:
   563                                                   for token in range(MAX_NUM_ASSETS):
   564                                                       if token == num_tokens:
   565                                                           break
   566                                                       packed_weights.append(pool.functions.packedWeight(token).call())
   567                                           
   568                                               for i in range(MAX_NUM_ASSETS):
   569                                                   token = (_tokens >> unsafe_mul(8, i)) & 255
   570                                                   if token == 0 or token > num_tokens:
   571                                                       break
   572                                                   token = unsafe_sub(token, 1)
   573                                                   prev_rate = pool.functions.rate(token).call()
   574                                           
   575                                                   provider_address = pool.functions.rateProviders(token).call()
   576                                                   provider = web3.eth.contract(
   577                                                       address=provider_address, abi=rate_provider_abi)
   578                                                   rate = provider.functions.rate(
   579                                                       pool.functions.tokens(token).call()).call()
   580                                                   assert rate > 0
   581                                                   rates.append(rate)
   582                                           
   583                                                   if rate == prev_rate:
   584                                                       continue
   585                                           
   586                                                   if prev_rate > 0 and vb_sum > 0:
   587                                                       # factor out old rate and factor in new
   588                                                       wn = _unpack_wn(packed_weights[token], num_tokens)
   589                                                       vb_prod = vb_prod * \
   590                                                           math._pow_up(int(prev_rate * PRECISION // rate),
   591                                                                        wn) / PRECISION
   592                                           
   593                                                       prev_bal = pool.functions.virtualBalance(token).call()
   594                                                       bal = prev_bal * rate // prev_rate
   595                                                       vb_sum = vb_sum + bal - prev_bal
   596                                           
   597                                               if not updated and vb_prod == _vb_prod and vb_sum == _vb_sum:
   598                                                   return pool.functions.supply().call(), amplification, vb_prod, vb_sum, packed_weights, rates
   599                                           
   600                                               supply = 0
   601                                               (supply, vb_prod) = _calc_supply(int(num_tokens),
   602                                                                                int(pool.functions.supply().call()), int(amplification), int(vb_prod), int(vb_sum), True)
   603                                               return supply, amplification, vb_prod, vb_sum, packed_weights, rates

Total time: 0 s
File: slippage_estimator.py
Function: _get_packed_weights at line 606

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   606                                           @profile
   607                                           def _get_packed_weights(_vb_prod: int, _vb_sum: int) -> (int, int, List[int], bool):
   608                                               packed_weights = []
   609                                               span = pool.functions.rampLastTime().call()
   610                                               duration = pool.functions.rampStopTime().call()
   611                                           
   612                                               block = web3.eth.get_block('latest')
   613                                               timestamp = block['timestamp']
   614                                               if span == 0 or span > timestamp or (block.timestamp - span < pool.functions.rampStep().call() and duration > timestamp):
   615                                                   return pool.functions.amplification().call(), _vb_prod, packed_weights, False
   616                                           
   617                                               if timestamp < duration:
   618                                                   # ramp in progress
   619                                                   duration -= span
   620                                               else:
   621                                                   #  ramp has finished
   622                                                   duration = 0
   623                                               span = timestamp - span
   624                                           
   625                                               #  update amplification
   626                                               current = pool.functions.amplification().call()
   627                                               target = pool.functions.targetAmplification().call()
   628                                           
   629                                               if duration == 0:
   630                                                   current = target
   631                                               else:
   632                                                   if current > target:
   633                                                       current = current - (current - target) * span / duration
   634                                                   else:
   635                                                       current = current + (target - current) * span / duration
   636                                               amplification = current
   637                                           
   638                                               #  update weights
   639                                               num_tokens = pool.functions.numTokens.call()
   640                                               supply = pool.functions.supply().call()
   641                                               vb_prod = 0
   642                                               if _vb_sum > 0:
   643                                                   vb_prod = PRECISION
   644                                               lower = 0
   645                                               upper = 0
   646                                               for token in range(MAX_NUM_ASSETS):
   647                                                   if token == num_tokens:
   648                                                       break
   649                                                   current, target, lower, upper = pool.functions.weight(token).call()
   650                                                   if duration == 0:
   651                                                       current = target
   652                                                   else:
   653                                                       if current > target:
   654                                                           current -= (current - target) * span / duration
   655                                                       else:
   656                                                           current += (target - current) * span / duration
   657                                                   packed_weights.append(_pack_weight(current, target, lower, upper))
   658                                                   if _vb_sum > 0:
   659                                                       vb_prod = unsafe_div(unsafe_mul(vb_prod, math._pow_down(unsafe_div(unsafe_mul(
   660                                                           supply, current), pool.functions.virtualBalance(token)), unsafe_mul(current, num_tokens))), PRECISION)
   661                                           
   662                                               return amplification, vb_prod, packed_weights, True

Total time: 0 s
File: slippage_estimator.py
Function: _pack_weight at line 665

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   665                                           @profile
   666                                           def _pack_weight(_weight: int, _target: int, _lower: int, _upper: int) -> int:
   667                                               return unsafe_div(_weight, WEIGHT_SCALE) | (unsafe_div(_target, WEIGHT_SCALE) << -TARGET_WEIGHT_SHIFT) | (unsafe_div(_lower, WEIGHT_SCALE) << -LOWER_BAND_SHIFT) | (unsafe_div(_upper, WEIGHT_SCALE) << -UPPER_BAND_SHIFT)

Total time: 0 s
File: slippage_estimator.py
Function: _unpack_weights at line 670

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   670                                           @profile
   671                                           def _unpack_weights(_packed: int) -> (int, int, int, int):
   672                                               return unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -TARGET_WEIGHT_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)

Total time: 0 s
File: slippage_estimator.py
Function: _unpack_wn at line 675

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   675                                           @profile
   676                                           def _unpack_wn(_packed: int, _num_tokens: int) -> int:
   677                                               return unsafe_mul(unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), _num_tokens)

Total time: 0 s
File: slippage_estimator.py
Function: _calc_supply at line 680

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   680                                           @profile
   681                                           def _calc_supply(_num_tokens: int, _supply: int, _amplification: int, _vb_prod: int, _vb_sum: int, _up: bool) -> (int, int):
   682                                               # s[n+1] = (A sum / w^n - s^(n+1) w^n /prod^n)) / (A w^n - 1)
   683                                               #        = (l - s r) / d
   684                                           
   685                                               l = _amplification
   686                                               d = l - PRECISION
   687                                               s = _supply
   688                                               r = _vb_prod
   689                                               l = l * _vb_sum
   690                                           
   691                                               num_tokens = _num_tokens
   692                                               for _ in range(255):
   693                                                   sp = unsafe_div(unsafe_sub(
   694                                                       l, unsafe_mul(s, r)), d)  # (l - s * r) / d
   695                                                   for i in range(MAX_NUM_ASSETS):
   696                                                       if i == num_tokens:
   697                                                           break
   698                                                       r = unsafe_div(unsafe_mul(r, sp), s)  # r * sp / s
   699                                                   if sp >= s:
   700                                                       if (sp - s) * PRECISION / s <= MAX_POW_REL_ERR:
   701                                                           if _up:
   702                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   703                                                           else:
   704                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   705                                                           return sp, r
   706                                                   else:
   707                                                       if (s - sp) * PRECISION / s <= MAX_POW_REL_ERR:
   708                                                           if _up:
   709                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   710                                                           else:
   711                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   712                                                           return sp, r
   713                                                   s = sp
   714                                           
   715                                               raise "no convergence"

Total time: 0 s
File: slippage_estimator.py
Function: _calc_vb at line 718

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   718                                           @profile
   719                                           def _calc_vb(_wn, _y, _supply, _amplification, _vb_prod, _vb_sum) -> int:
   720                                               # y = x_j, sum' = sum(x_i, i != j), prod' = prod(x_i^w_i, i != j)
   721                                               # w = product(w_i), v_i = w_i n, f_i = 1/v_i
   722                                               # Iteratively find root of g(y) using Newton's method
   723                                               # g(y) = y^(v_j + 1) + (sum' + (w^n / A - 1) D y^(w_j n) - D^(n+1) w^2n / prod'^n
   724                                               #      = y^(v_j + 1) + b y^(v_j) - c
   725                                               # y[n+1] = y[n] - g(y[n])/g'(y[n])
   726                                               #        = (y[n]^2 + b (1 - f_j) y[n] + c f_j y[n]^(1 - v_j)) / (f_j + 1) y[n] + b)
   727                                           
   728                                               d = _supply
   729                                               b = d * PRECISION / _amplification  # actually b + D
   730                                               c = _vb_prod * b / PRECISION
   731                                               b += _vb_sum
   732                                               f = PRECISION * PRECISION / _wn
   733                                           
   734                                               y = _y
   735                                               for _ in range(255):
   736                                                   yp = (y + b + d * f / PRECISION + c * f / math._pow_up(int(y), int(_wn)) -
   737                                                         b * f / PRECISION - d) * y / (f * y / PRECISION + y + b - d)
   738                                                   if yp >= y:
   739                                                       if (yp - y) * PRECISION / y <= MAX_POW_REL_ERR:
   740                                                           yp += yp * MAX_POW_REL_ERR / PRECISION
   741                                                           return yp
   742                                                   else:
   743                                                       if (y - yp) * PRECISION / y <= MAX_POW_REL_ERR:
   744                                                           yp += yp * MAX_POW_REL_ERR / PRECISION
   745                                                           return yp
   746                                                   y = yp
   747                                           
   748                                               raise "no convergence"

Total time: 0 s
File: slippage_estimator.py
Function: _check_bands at line 751

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   751                                           @profile
   752                                           def _check_bands(_prev_ratio, _ratio, _packed_weight):
   753                                               weight = unsafe_mul(_packed_weight & WEIGHT_MASK, WEIGHT_SCALE)
   754                                           
   755                                               # lower limit check
   756                                               limit = unsafe_mul(
   757                                                   (_packed_weight >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE)
   758                                               if limit > weight:
   759                                                   limit = 0
   760                                               else:
   761                                                   limit = unsafe_sub(weight, limit)
   762                                               if _ratio < limit:
   763                                                   assert _ratio > _prev_ratio  # dev: ratio below lower band
   764                                           
   765                                               # upper limit check
   766                                               limit = min(unsafe_add(weight, unsafe_mul(
   767                                                   (_packed_weight >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)), PRECISION)
   768                                               if _ratio > limit:
   769                                                   assert _ratio < _prev_ratio  # dev: ratio above upper band

