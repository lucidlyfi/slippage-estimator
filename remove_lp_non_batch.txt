preparing batch
batch - <web3._utils.batching.RequestBatcher object at 0x1071dd5d0>
[287977411355084561, 1018644744779206231, 120126624584960075, 1152922604118684467398000, '0xC4EF2c4B4eD79CD7639AF070d4a6A82eEF5edd4f', [198000000000000000, 198000000000000000, 1000000000000000000, 1000000000000000000], 287977411355084561, 1033787537773505606, 99076551634608604, 1152922604118894182796000, '0xC4EF2c4B4eD79CD7639AF070d4a6A82eEF5edd4f', [396000000000000000, 396000000000000000, 1000000000000000000, 1000000000000000000], 287977411355084561, 1019361644041752561, 38823262861639147, 1152922604118894182796000, '0xC4EF2c4B4eD79CD7639AF070d4a6A82eEF5edd4f', [396000000000000000, 396000000000000000, 1000000000000000000, 1000000000000000000], 287977411355084561, 1018924890012449380, 31530616370904106, 1152922604118485237770000, '0x73717f7FF55E0acDB1F5f5789D13d7c40A08E4CA', [10000000000000000, 10000000000000000, 1000000000000000000, 1000000000000000000], [3468387504136021175, 289557055452111932], 0, 0, 450000000000000000000, 0]
result - 234189254215979168
Wrote profile results to slippage_estimator.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: slippage_estimator.py
Function: get_output_token at line 339

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   339                                           @profile
   340                                           async def get_output_token(_i: int, _j: int, _dx: int) -> int:
   341                                               #  num_tokens = pool.functions.numTokens().call()
   342                                               num_tokens = 4
   343                                               assert _i != _j  # dev: same input and output asset
   344                                               assert _i < num_tokens and _j < num_tokens  # dev: index out of bounds
   345                                               assert _dx > 0  # dev: zero amount
   346                                           
   347                                               # update rates for from and to assets
   348                                               supply = 0
   349                                               amplification = 0
   350                                               vb_prod = 0
   351                                               vb_sum = 0
   352                                               vb_prod, vb_sum = await pool.functions.virtualBalanceProdSum().call()
   353                                               packed_weights = []
   354                                               rates = []
   355                                               supply, amplification, vb_prod, vb_sum, packed_weights, rates = await _get_rates(
   356                                                   unsafe_add(_i, 1) | (unsafe_add(_j, 1) << 8), vb_prod, vb_sum)
   357                                               prev_vb_sum = vb_sum
   358                                           
   359                                               prev_vb_x = await pool.functions.virtualBalance(
   360                                                   _i).call() * rates[0] / (await pool.functions.rate(_i).call())
   361                                               wn_x = _unpack_wn(packed_weights[_i], num_tokens)
   362                                           
   363                                               prev_vb_y = await pool.functions.virtualBalance(
   364                                                   _j).call() * rates[1] / (await pool.functions.rate(_j).call())
   365                                               wn_y = _unpack_wn(packed_weights[_j], num_tokens)
   366                                           
   367                                               dx_fee = _dx * pool.functions.swapFeeRate().call() / PRECISION
   368                                               dvb_x = (_dx - dx_fee) * rates[0] / PRECISION
   369                                               vb_x = prev_vb_x + dvb_x
   370                                           
   371                                               # update x_i and remove x_j from variables
   372                                               vb_prod = vb_prod * math._pow_up(int(prev_vb_y), (wn_y)) / \
   373                                                   math._pow_down(int(vb_x * PRECISION // prev_vb_x), int(wn_x))
   374                                               vb_sum = vb_sum + dvb_x - prev_vb_y
   375                                           
   376                                               # calulate new balance of out token
   377                                               vb_y = _calc_vb(int(wn_y), int(prev_vb_y), int(supply),
   378                                                               int(amplification), int(vb_prod), int(vb_sum))
   379                                               vb_sum += vb_y + dx_fee * rates[0] // PRECISION
   380                                           
   381                                               # check bands
   382                                               _check_bands(prev_vb_x * PRECISION // prev_vb_sum,
   383                                                            vb_x * PRECISION // vb_sum, packed_weights[_i])
   384                                               _check_bands(prev_vb_y * PRECISION // prev_vb_sum,
   385                                                            vb_y * PRECISION // vb_sum, packed_weights[_j])
   386                                           
   387                                               return (prev_vb_y - vb_y) * PRECISION / rates[1]

Total time: 0.125078 s
File: slippage_estimator.py
Function: get_add_lp at line 390

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   390                                           @profile
   391                                           async def get_add_lp(_amounts: List[int]) -> int:
   392         1         12.0     12.0      0.0      batch = web3.batch_requests()
   393                                           
   394         1          0.0      0.0      0.0      rates = []
   395         1          0.0      0.0      0.0      virtual_balances = []
   396         1          0.0      0.0      0.0      packed_weights = []
   397         1          0.0      0.0      0.0      rate_providers = []
   398         1          0.0      0.0      0.0      weights = []
   399                                           
   400         1          2.0      2.0      0.0      print("preparing batch")
   401                                           
   402         5          3.0      0.6      0.0      for t in range(4):
   403         4        341.0     85.2      0.3          batch.add(pool.functions.supply().call())
   404         4        902.0    225.5      0.7          batch.add(pool.functions.rate(t).call())
   405         4        363.0     90.8      0.3          batch.add(pool.functions.virtualBalance(t).call())
   406         4        349.0     87.2      0.3          batch.add(pool.functions.packedWeight(t).call())
   407         4        343.0     85.8      0.3          batch.add(pool.functions.rateProviders(t).call())
   408         4        336.0     84.0      0.3          batch.add(pool.functions.weight(t).call())
   409                                           
   410         1         70.0     70.0      0.1      batch.add(pool.functions.virtualBalanceProdSum().call())
   411         1         71.0     71.0      0.1      batch.add(pool.functions.rampLastTime().call())
   412         1         70.0     70.0      0.1      batch.add(pool.functions.rampStopTime().call())
   413         1         70.0     70.0      0.1      batch.add(pool.functions.amplification().call())
   414         1         69.0     69.0      0.1      batch.add(pool.functions.targetAmplification().call())
   415                                           
   416         1          2.0      2.0      0.0      print("batch -", batch)
   417                                           
   418         1        256.0    256.0      0.2      responses = await batch.async_execute()
   419                                           
   420         1         23.0     23.0      0.0      print(responses)
   421                                           
   422         1          0.0      0.0      0.0      num_tokens = 4
   423         1          0.0      0.0      0.0      assert len(_amounts) == num_tokens
   424                                           
   425         1          0.0      0.0      0.0      vb_prod = 0
   426         1          0.0      0.0      0.0      vb_sum = 0
   427         1       1422.0   1422.0      1.1      vb_prod, vb_sum = await pool.functions.virtualBalanceProdSum().call()
   428         1          6.0      6.0      0.0      assert vb_sum > 0
   429                                           
   430                                               # find lowest relative increase in balance
   431         1          0.0      0.0      0.0      tokens = 0
   432         1          5.0      5.0      0.0      lowest = 2**256 - 1
   433         1          1.0      1.0      0.0      sh = 0
   434         5          8.0      1.6      0.0      for token in range(MAX_NUM_ASSETS):
   435         5          3.0      0.6      0.0          if token == num_tokens:
   436         1          0.0      0.0      0.0              break
   437         4          5.0      1.2      0.0          if _amounts[token] > 0:
   438         4         33.0      8.2      0.0              tokens = tokens | (unsafe_add(token, 1) << sh)
   439         4          3.0      0.8      0.0              sh = unsafe_add(sh, 8)
   440         4          5.0      1.2      0.0              if vb_sum > 0 and lowest > 0:
   441        12      13797.0   1149.8     11.0                  lowest = min(_amounts[token] * (await pool.functions.rate(token).call()) /
   442         8      14760.0   1845.0     11.8                               (await pool.functions.virtualBalance(token).call()), lowest)
   443                                                   else:
   444                                                       lowest = 0
   445         1          1.0      1.0      0.0      assert (sh > 0)
   446                                           
   447                                               # update rates
   448         1          0.0      0.0      0.0      prev_supply = 0
   449         1          0.0      0.0      0.0      amplification = 0
   450         1          2.0      2.0      0.0      packed_weights = []
   451         1          1.0      1.0      0.0      rates = []
   452                                           
   453         2       2751.0   1375.5      2.2      prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = await _get_rates(
   454         1          2.0      2.0      0.0          tokens, vb_prod, vb_sum)
   455                                           
   456         1          1.0      1.0      0.0      vb_prod_final = vb_prod
   457         1          0.0      0.0      0.0      vb_sum_final = vb_sum
   458                                               # fee_rate = int((await pool.functions.swapFeeRate().call()) / 2)
   459         1          1.0      1.0      0.0      fee_rate = int(150000000000000)
   460         1          0.0      0.0      0.0      prev_vb_sum = vb_sum
   461         1          0.0      0.0      0.0      balances = []
   462         1          1.0      1.0      0.0      j = 0
   463         5          3.0      0.6      0.0      for token in range(MAX_NUM_ASSETS):
   464         5          3.0      0.6      0.0          if token == num_tokens:
   465         1          1.0      1.0      0.0              break
   466                                           
   467         4          3.0      0.8      0.0          amount = _amounts[token]
   468         4          3.0      0.8      0.0          if amount == 0:
   469                                                       continue
   470                                           
   471        20      21273.0   1063.7     17.0          prev_vb = (await pool.functions.virtualBalance(
   472        16      22182.0   1386.4     17.7              token).call()) * rates[j] / (await pool.functions.rate(token).call())
   473                                           
   474         4         34.0      8.5      0.0          dvb = amount * rates[j] / PRECISION
   475         4          5.0      1.2      0.0          vb = prev_vb + dvb
   476         4          8.0      2.0      0.0          balances.append(vb)
   477                                           
   478         4          8.0      2.0      0.0          if prev_supply > 0:
   479         4        204.0     51.0      0.2              wn = _unpack_wn(packed_weights[token], num_tokens)
   480                                           
   481                                                       # update product and sum of virtual balances
   482        12         14.0      1.2      0.0              vb_prod_final = vb_prod_final * \
   483         8        903.0    112.9      0.7                  math._pow_up(int(prev_vb * PRECISION / vb), wn) / PRECISION
   484                                                       # the `D^n` factor will be updated in `_calc_supply()`
   485         4          6.0      1.5      0.0              vb_sum_final += dvb
   486                                           
   487                                                       # remove fees from balance and recalculate sum and product
   488        16         20.0      1.2      0.0              fee = (dvb - prev_vb * lowest /
   489        12          4.0      0.3      0.0                     PRECISION) * fee_rate / PRECISION
   490        12          9.0      0.8      0.0              vb_prod = vb_prod * \
   491        12        548.0     45.7      0.4                  math._pow_up(int(prev_vb * PRECISION /
   492        12          6.0      0.5      0.0                               (vb - fee)), wn) / PRECISION
   493         4          4.0      1.0      0.0              vb_sum += dvb - fee
   494         4         13.0      3.2      0.0          j = unsafe_add(j, 1)
   495                                           
   496                                               #  check bands
   497         1          1.0      1.0      0.0      j = 0
   498         5          8.0      1.6      0.0      for token in range(MAX_NUM_ASSETS):
   499         5          4.0      0.8      0.0          if token == num_tokens:
   500         1          1.0      1.0      0.0              break
   501         4          6.0      1.5      0.0          if _amounts[token] == 0:
   502                                                       continue
   503        24      42649.0   1777.0     34.1          _check_bands((await pool.functions.virtualBalance(token).call()) * rates[j] / (await pool.functions.rate(
   504        20         64.0      3.2      0.1              token).call()) * PRECISION / prev_vb_sum, balances[j] * PRECISION / vb_sum_final, packed_weights[token])
   505         4         14.0      3.5      0.0          j = unsafe_add(j, 1)
   506                                           
   507         1          1.0      1.0      0.0      supply = 0
   508         2        982.0    491.0      0.8      (supply, vb_prod) = _calc_supply(int(num_tokens), int(prev_supply),
   509         1          3.0      3.0      0.0                                       int(amplification), int(vb_prod), int(vb_sum), prev_supply == 0)
   510         1          1.0      1.0      0.0      return supply - prev_supply

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_lp at line 513

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   513                                           @profile
   514                                           async def get_remove_lp(_lp_amount: int) -> List[int]:
   515                                               amounts = []
   516                                               num_tokens = 4
   517                                           
   518                                               rates = []
   519                                               prev_balances = []
   520                                           
   521                                               batch = web3.batch_requests()
   522                                           
   523                                               batch.add(pool.functions.supply().call())
   524                                           
   525                                               for t in range(4):
   526                                                   batch.add(pool.functions.virtualBalance(t).call())
   527                                                   batch.add(pool.functions.rate(t).call())
   528                                           
   529                                               responses = await batch.async_execute()
   530                                           
   531                                               prev_supply = responses[0]
   532                                           
   533                                               for i in range(4):
   534                                                   prev_balances.append(responses[2*i + 1])
   535                                                   rates.append(responses[2*i+2])
   536                                           
   537                                               assert (_lp_amount <= prev_supply)
   538                                           
   539                                               for token in range(MAX_NUM_ASSETS):
   540                                                   if token == num_tokens:
   541                                                       break
   542                                                   prev_bal = prev_balances[token]
   543                                                   dbal = prev_bal * _lp_amount // prev_supply
   544                                                   amount = dbal * PRECISION // rates[token]
   545                                                   amounts.append(amount)
   546                                           
   547                                               return amounts

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_single_lp at line 550

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   550                                           @profile
   551                                           def get_remove_single_lp(_token: int, _lp_amount: int) -> int:
   552                                               num_tokens = pool.functions.numTokens().call()
   553                                               assert _token < num_tokens
   554                                           
   555                                               #  update rate
   556                                               prev_supply = 0
   557                                               amplification = 0
   558                                               vb_prod = 0
   559                                               vb_sum = 0
   560                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   561                                               packed_weights = []
   562                                               rates = []
   563                                               prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   564                                                   unsafe_add(_token, 1), vb_prod, vb_sum)
   565                                               prev_vb_sum = vb_sum
   566                                           
   567                                               supply = prev_supply - _lp_amount
   568                                               prev_vb = pool.functions.virtualBalance(_token).call(
   569                                               ) * rates[0] / pool.functions.rate(_token).call()
   570                                               wn = _unpack_wn(packed_weights[_token], num_tokens)
   571                                           
   572                                               #  update variables
   573                                               vb_prod = vb_prod * math._pow_up(int(prev_vb), int(wn)) / PRECISION
   574                                               for i in range(MAX_NUM_ASSETS):
   575                                                   if i == num_tokens:
   576                                                       break
   577                                                   vb_prod = vb_prod * supply / prev_supply
   578                                               vb_sum = vb_sum - prev_vb
   579                                           
   580                                               #  calculate new balance of token
   581                                               vb = _calc_vb(int(wn), int(prev_vb), int(supply), int(
   582                                                   amplification), int(vb_prod), int(vb_sum))
   583                                               dvb = prev_vb - vb
   584                                               fee = int(dvb) * pool.functions.swapFeeRate().call() // 2 // PRECISION
   585                                               dvb -= fee
   586                                               vb += fee
   587                                               dx = dvb * PRECISION / rates[0]
   588                                               vb_sum = vb_sum + vb
   589                                           
   590                                               for token in range(MAX_NUM_ASSETS):
   591                                                   if token == num_tokens:
   592                                                       break
   593                                                   if token == _token:
   594                                                       _check_bands(prev_vb * PRECISION // prev_vb_sum, vb *
   595                                                                    PRECISION // vb_sum, packed_weights[token])
   596                                                   else:
   597                                                       bal = pool.functions.virtualBalance(token).call()
   598                                                       _check_bands(bal * PRECISION / prev_vb_sum, bal *
   599                                                                    PRECISION // vb_sum, packed_weights[token])
   600                                           
   601                                               return dx

Total time: 0.106845 s
File: slippage_estimator.py
Function: _get_rates at line 604

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   604                                           @profile
   605                                           async def _get_rates(_tokens: int, _vb_prod: int, _vb_sum: int) -> (int, int, int, int, List[int], List[int]):
   606         1          1.0      1.0      0.0      packed_weights = []
   607         1          1.0      1.0      0.0      rates = []
   608                                           
   609         1          1.0      1.0      0.0      amplification = 0
   610         1          0.0      0.0      0.0      vb_prod = 0
   611         1          1.0      1.0      0.0      vb_sum = _vb_sum
   612         2       2700.0   1350.0      2.5      amplification, vb_prod, _packed_weights, updated = await _get_packed_weights(
   613         1          0.0      0.0      0.0          _vb_prod, _vb_sum)
   614                                           
   615                                               # num_tokens = pool.functions.numTokens().call()
   616         1          1.0      1.0      0.0      num_tokens = 4
   617                                           
   618         1          0.0      0.0      0.0      if not updated:
   619         5          7.0      1.4      0.0          for token in range(MAX_NUM_ASSETS):
   620         5          2.0      0.4      0.0              if token == num_tokens:
   621         1          0.0      0.0      0.0                  break
   622         4      11928.0   2982.0     11.2              packed_weight = await pool.functions.packedWeight(token).call()
   623         4         15.0      3.8      0.0              packed_weights.append(packed_weight)
   624                                           
   625         5          5.0      1.0      0.0      for i in range(MAX_NUM_ASSETS):
   626         5         34.0      6.8      0.0          token = (_tokens >> unsafe_mul(8, i)) & 255
   627         5          4.0      0.8      0.0          if token == 0 or token > num_tokens:
   628         1          0.0      0.0      0.0              break
   629         4          8.0      2.0      0.0          token = unsafe_sub(token, 1)
   630         4      18115.0   4528.8     17.0          prev_rate = await pool.functions.rate(token).call()
   631                                           
   632         4      15098.0   3774.5     14.1          provider_address = await pool.functions.rateProviders(token).call()
   633         8       4312.0    539.0      4.0          provider = web3.eth.contract(
   634         4         41.0     10.2      0.0              address=provider_address, abi=rate_provider_abi)
   635        12      20316.0   1693.0     19.0          rate = await provider.functions.rate(
   636         8      14713.0   1839.1     13.8              await pool.functions.tokens(token).call()).call()
   637         4         13.0      3.2      0.0          assert rate > 0
   638         4          8.0      2.0      0.0          rates.append(rate)
   639                                           
   640         4          2.0      0.5      0.0          if rate == prev_rate:
   641                                                       continue
   642                                           
   643         4          3.0      0.8      0.0          if prev_rate > 0 and vb_sum > 0:
   644                                                       # factor out old rate and factor in new
   645         4        131.0     32.8      0.1              wn = _unpack_wn(packed_weights[token], num_tokens)
   646        12         32.0      2.7      0.0              vb_prod = vb_prod * \
   647         8        534.0     66.8      0.5                  math._pow_up(int(prev_rate * PRECISION // rate),
   648         8          3.0      0.4      0.0                               wn) / PRECISION
   649                                           
   650         4      14675.0   3668.8     13.7              prev_bal = await pool.functions.virtualBalance(token).call()
   651         4         21.0      5.2      0.0              bal = prev_bal * rate // prev_rate
   652         4         12.0      3.0      0.0              vb_sum = vb_sum + bal - prev_bal
   653                                           
   654         1          4.0      4.0      0.0      if not updated and vb_prod == _vb_prod and vb_sum == _vb_sum:
   655                                                   return (await pool.functions.supply().call()), amplification, vb_prod, vb_sum, packed_weights, rates
   656                                           
   657         1          0.0      0.0      0.0      supply = 0
   658         2        535.0    267.5      0.5      (supply, vb_prod) = _calc_supply(int(num_tokens),
   659         1       3568.0   3568.0      3.3                                       int(await pool.functions.supply().call()), int(amplification), int(vb_prod), int(vb_sum), True)
   660         1          1.0      1.0      0.0      return supply, amplification, vb_prod, vb_sum, packed_weights, rates

Total time: 0.009288 s
File: slippage_estimator.py
Function: _get_packed_weights at line 663

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   663                                           @profile
   664                                           async def _get_packed_weights(_vb_prod: int, _vb_sum: int) -> (int, int, List[int], bool):
   665         1          2.0      2.0      0.0      packed_weights = []
   666         1       2681.0   2681.0     28.9      span = await pool.functions.rampLastTime().call()
   667         1       2604.0   2604.0     28.0      duration = await pool.functions.rampStopTime().call()
   668                                           
   669         1        864.0    864.0      9.3      block = await web3.eth.get_block('latest')
   670         1          2.0      2.0      0.0      timestamp = block['timestamp']
   671         1          1.0      1.0      0.0      if span == 0 or span > timestamp or (block.timestamp - span < (await pool.functions.rampStep().call()) and duration > timestamp):
   672         1       3134.0   3134.0     33.7          return (await pool.functions.amplification().call()), _vb_prod, packed_weights, False
   673                                           
   674                                               if timestamp < duration:
   675                                                   # ramp in progress
   676                                                   duration -= span
   677                                               else:
   678                                                   #  ramp has finished
   679                                                   duration = 0
   680                                               span = timestamp - span
   681                                           
   682                                               #  update amplification
   683                                               current = await pool.functions.amplification().call()
   684                                               target = await pool.functions.targetAmplification().call()
   685                                           
   686                                               if duration == 0:
   687                                                   current = target
   688                                               else:
   689                                                   if current > target:
   690                                                       current = current - (current - target) * span / duration
   691                                                   else:
   692                                                       current = current + (target - current) * span / duration
   693                                               amplification = current
   694                                           
   695                                               #  update weights
   696                                               num_tokens = 4
   697                                               supply = await pool.functions.supply().call()
   698                                               vb_prod = 0
   699                                               if _vb_sum > 0:
   700                                                   vb_prod = PRECISION
   701                                               lower = 0
   702                                               upper = 0
   703                                               for token in range(MAX_NUM_ASSETS):
   704                                                   if token == num_tokens:
   705                                                       break
   706                                                   current, target, lower, upper = (await pool.functions.weight(token).call())
   707                                                   if duration == 0:
   708                                                       current = target
   709                                                   else:
   710                                                       if current > target:
   711                                                           current -= (current - target) * span / duration
   712                                                       else:
   713                                                           current += (target - current) * span / duration
   714                                                   packed_weights.append(_pack_weight(current, target, lower, upper))
   715                                                   if _vb_sum > 0:
   716                                                       vb_prod = unsafe_div(unsafe_mul(vb_prod, math._pow_down(unsafe_div(unsafe_mul(
   717                                                           supply, current), (await pool.functions.virtualBalance(token))), unsafe_mul(current, num_tokens))), PRECISION)
   718                                           
   719                                               return amplification, vb_prod, packed_weights, True

Total time: 0 s
File: slippage_estimator.py
Function: _pack_weight at line 722

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   722                                           @profile
   723                                           def _pack_weight(_weight: int, _target: int, _lower: int, _upper: int) -> int:
   724                                               return unsafe_div(_weight, WEIGHT_SCALE) | (unsafe_div(_target, WEIGHT_SCALE) << -TARGET_WEIGHT_SHIFT) | (unsafe_div(_lower, WEIGHT_SCALE) << -LOWER_BAND_SHIFT) | (unsafe_div(_upper, WEIGHT_SCALE) << -UPPER_BAND_SHIFT)

Total time: 0 s
File: slippage_estimator.py
Function: _unpack_weights at line 727

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   727                                           @profile
   728                                           def _unpack_weights(_packed: int) -> (int, int, int, int):
   729                                               return unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -TARGET_WEIGHT_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)

Total time: 7.2e-05 s
File: slippage_estimator.py
Function: _unpack_wn at line 732

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   732                                           @profile
   733                                           def _unpack_wn(_packed: int, _num_tokens: int) -> int:
   734         8         72.0      9.0    100.0      return unsafe_mul(unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), _num_tokens)

Total time: 0.000785 s
File: slippage_estimator.py
Function: _calc_supply at line 737

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   737                                           @profile
   738                                           def _calc_supply(_num_tokens: int, _supply: int, _amplification: int, _vb_prod: int, _vb_sum: int, _up: bool) -> (int, int):
   739                                               # s[n+1] = (A sum / w^n - s^(n+1) w^n /prod^n)) / (A w^n - 1)
   740                                               #        = (l - s r) / d
   741                                           
   742         2          1.0      0.5      0.1      l = _amplification
   743         2          4.0      2.0      0.5      d = l - PRECISION
   744         2          1.0      0.5      0.1      s = _supply
   745         2          1.0      0.5      0.1      r = _vb_prod
   746         2          2.0      1.0      0.3      l = l * _vb_sum
   747                                           
   748         2          1.0      0.5      0.1      num_tokens = _num_tokens
   749        23         14.0      0.6      1.8      for _ in range(255):
   750        69         69.0      1.0      8.8          sp = unsafe_div(unsafe_sub(
   751        46         38.0      0.8      4.8              l, unsafe_mul(s, r)), d)  # (l - s * r) / d
   752       115         66.0      0.6      8.4          for i in range(MAX_NUM_ASSETS):
   753       115        103.0      0.9     13.1              if i == num_tokens:
   754        23          8.0      0.3      1.0                  break
   755        92        268.0      2.9     34.1              r = unsafe_div(unsafe_mul(r, sp), s)  # r * sp / s
   756        23          7.0      0.3      0.9          if sp >= s:
   757        12        160.0     13.3     20.4              if (sp - s) * PRECISION / s <= MAX_POW_REL_ERR:
   758         1          0.0      0.0      0.0                  if _up:
   759                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   760                                                           else:
   761         1          4.0      4.0      0.5                      sp -= sp * MAX_POW_REL_ERR / PRECISION
   762         1          1.0      1.0      0.1                  return sp, r
   763                                                   else:
   764        11         20.0      1.8      2.5              if (s - sp) * PRECISION / s <= MAX_POW_REL_ERR:
   765         1          0.0      0.0      0.0                  if _up:
   766         1          2.0      2.0      0.3                      sp += sp * MAX_POW_REL_ERR / PRECISION
   767                                                           else:
   768                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   769         1          1.0      1.0      0.1                  return sp, r
   770        21         14.0      0.7      1.8          s = sp
   771                                           
   772                                               raise "no convergence"

Total time: 0 s
File: slippage_estimator.py
Function: _calc_vb at line 775

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   775                                           @profile
   776                                           def _calc_vb(_wn, _y, _supply, _amplification, _vb_prod, _vb_sum) -> int:
   777                                               # y = x_j, sum' = sum(x_i, i != j), prod' = prod(x_i^w_i, i != j)
   778                                               # w = product(w_i), v_i = w_i n, f_i = 1/v_i
   779                                               # Iteratively find root of g(y) using Newton's method
   780                                               # g(y) = y^(v_j + 1) + (sum' + (w^n / A - 1) D y^(w_j n) - D^(n+1) w^2n / prod'^n
   781                                               #      = y^(v_j + 1) + b y^(v_j) - c
   782                                               # y[n+1] = y[n] - g(y[n])/g'(y[n])
   783                                               #        = (y[n]^2 + b (1 - f_j) y[n] + c f_j y[n]^(1 - v_j)) / (f_j + 1) y[n] + b)
   784                                           
   785                                               d = _supply
   786                                               b = d * PRECISION // _amplification  # actually b + D
   787                                               c = _vb_prod * b // PRECISION
   788                                               b += _vb_sum
   789                                               f = PRECISION * PRECISION // _wn
   790                                           
   791                                               y = _y
   792                                               for _ in range(255):
   793                                                   yp = (y + b + d * f // PRECISION + c * f // math._pow_up(int(y), int(_wn)) -
   794                                                         b * f // PRECISION - d) * y // (f * y // PRECISION + y + b - d)
   795                                                   if yp >= y:
   796                                                       if (yp - y) * PRECISION // y <= MAX_POW_REL_ERR:
   797                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   798                                                           return yp
   799                                                   else:
   800                                                       if (y - yp) * PRECISION // y <= MAX_POW_REL_ERR:
   801                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   802                                                           return yp
   803                                                   y = yp
   804                                           
   805                                               raise "no convergence"

Total time: 0.000145 s
File: slippage_estimator.py
Function: _check_bands at line 808

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   808                                           @profile
   809                                           def _check_bands(_prev_ratio, _ratio, _packed_weight):
   810         4         45.0     11.2     31.0      weight = unsafe_mul(_packed_weight & WEIGHT_MASK, WEIGHT_SCALE)
   811                                           
   812                                               # lower limit check
   813         8          4.0      0.5      2.8      limit = unsafe_mul(
   814         4         22.0      5.5     15.2          (_packed_weight >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE)
   815         4          1.0      0.2      0.7      if limit > weight:
   816         4          5.0      1.2      3.4          limit = 0
   817                                               else:
   818                                                   limit = unsafe_sub(weight, limit)
   819         4          4.0      1.0      2.8      if _ratio < limit:
   820                                                   assert _ratio > _prev_ratio  # dev: ratio below lower band
   821                                           
   822                                               # upper limit check
   823        12         36.0      3.0     24.8      limit = min(unsafe_add(weight, unsafe_mul(
   824         8         11.0      1.4      7.6          (_packed_weight >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)), PRECISION)
   825         4         17.0      4.2     11.7      if _ratio > limit:
   826                                                   assert _ratio < _prev_ratio  # dev: ratio above upper band

Total time: 0.003299 s
File: slippage_estimator.py
Function: main at line 829

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   829                                           @profile
   830                                           async def main():
   831         2       3271.0   1635.5     99.2      result = await get_add_lp([int(0.1 * PRECISION), int(0.1 * PRECISION),
   832         1          0.0      0.0      0.0                                 int(0.02 * PRECISION), int(0.01 * PRECISION)])
   833                                               #  result = await get_remove_lp(1e6)
   834         1         28.0     28.0      0.8      print("result -", int(result))

