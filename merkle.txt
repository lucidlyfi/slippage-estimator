97056061
Wrote profile results to slippage_estimator.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: slippage_estimator.py
Function: get_output_token at line 341

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   341                                           @profile
   342                                           def get_output_token(_i: int, _j: int, _dx: int) -> int:
   343                                               num_tokens = pool.functions.numTokens().call()
   344                                               assert _i != _j  # dev: same input and output asset
   345                                               assert _i < num_tokens and _j < num_tokens  # dev: index out of bounds
   346                                               assert _dx > 0  # dev: zero amount
   347                                           
   348                                               # update rates for from and to assets
   349                                               supply = 0
   350                                               amplification = 0
   351                                               vb_prod = 0
   352                                               vb_sum = 0
   353                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   354                                               packed_weights = []
   355                                               rates = []
   356                                               supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   357                                                   unsafe_add(_i, 1) | (unsafe_add(_j, 1) << 8), vb_prod, vb_sum)
   358                                               prev_vb_sum = vb_sum
   359                                           
   360                                               prev_vb_x = pool.functions.virtualBalance(
   361                                                   _i).call() * rates[0] / pool.functions.rate(_i).call()
   362                                               wn_x = _unpack_wn(packed_weights[_i], num_tokens)
   363                                           
   364                                               prev_vb_y = pool.functions.virtualBalance(
   365                                                   _j).call() * rates[1] / pool.functions.rate(_j).call()
   366                                               wn_y = _unpack_wn(packed_weights[_j], num_tokens)
   367                                           
   368                                               dx_fee = _dx * pool.functions.swapFeeRate().call() / PRECISION
   369                                               dvb_x = (_dx - dx_fee) * rates[0] / PRECISION
   370                                               vb_x = prev_vb_x + dvb_x
   371                                           
   372                                               # update x_i and remove x_j from variables
   373                                               vb_prod = vb_prod * math._pow_up(int(prev_vb_y), (wn_y)) / \
   374                                                   math._pow_down(int(vb_x * PRECISION // prev_vb_x), int(wn_x))
   375                                               vb_sum = vb_sum + dvb_x - prev_vb_y
   376                                           
   377                                               # calulate new balance of out token
   378                                               vb_y = _calc_vb(int(wn_y), int(prev_vb_y), int(supply),
   379                                                               int(amplification), int(vb_prod), int(vb_sum))
   380                                               vb_sum += vb_y + dx_fee * rates[0] // PRECISION
   381                                           
   382                                               # check bands
   383                                               _check_bands(prev_vb_x * PRECISION // prev_vb_sum,
   384                                                            vb_x * PRECISION // vb_sum, packed_weights[_i])
   385                                               _check_bands(prev_vb_y * PRECISION // prev_vb_sum,
   386                                                            vb_y * PRECISION // vb_sum, packed_weights[_j])
   387                                           
   388                                               return (prev_vb_y - vb_y) * PRECISION / rates[1]

Total time: 0 s
File: slippage_estimator.py
Function: get_add_lp at line 391

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   391                                           @profile
   392                                           def get_add_lp(_amounts: List[int]) -> int:
   393                                               num_tokens = pool.functions.numTokens().call()
   394                                               assert len(_amounts) == num_tokens
   395                                           
   396                                               vb_prod = 0
   397                                               vb_sum = 0
   398                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   399                                               assert vb_sum > 0
   400                                           
   401                                               # find lowest relative increase in balance
   402                                               tokens = 0
   403                                               lowest = 2**256 - 1
   404                                               sh = 0
   405                                               for token in range(MAX_NUM_ASSETS):
   406                                                   if token == num_tokens:
   407                                                       break
   408                                                   if _amounts[token] > 0:
   409                                                       tokens = tokens | (unsafe_add(token, 1) << sh)
   410                                                       sh = unsafe_add(sh, 8)
   411                                                       if vb_sum > 0 and lowest > 0:
   412                                                           lowest = min(_amounts[token] * pool.functions.rate(token).call() /
   413                                                                        pool.functions.virtualBalance(token).call(), lowest)
   414                                                   else:
   415                                                       lowest = 0
   416                                               assert (sh > 0)
   417                                           
   418                                               # update rates
   419                                               prev_supply = 0
   420                                               amplification = 0
   421                                               packed_weights = []
   422                                               rates = []
   423                                           
   424                                               prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   425                                                   tokens, vb_prod, vb_sum)
   426                                           
   427                                               vb_prod_final = vb_prod
   428                                               vb_sum_final = vb_sum
   429                                               fee_rate = pool.functions.swapFeeRate().call() / 2
   430                                               prev_vb_sum = vb_sum
   431                                               balances = []
   432                                               j = 0
   433                                               for token in range(MAX_NUM_ASSETS):
   434                                                   if token == num_tokens:
   435                                                       break
   436                                           
   437                                                   amount = _amounts[token]
   438                                                   if amount == 0:
   439                                                       continue
   440                                           
   441                                                   prev_vb = pool.functions.virtualBalance(
   442                                                       token).call() * rates[j] / pool.functions.rate(token).call()
   443                                           
   444                                                   dvb = amount * rates[j] / PRECISION
   445                                                   vb = prev_vb + dvb
   446                                                   balances.append(vb)
   447                                           
   448                                                   if prev_supply > 0:
   449                                                       wn = _unpack_wn(packed_weights[token], num_tokens)
   450                                           
   451                                                       # update product and sum of virtual balances
   452                                                       vb_prod_final = vb_prod_final * \
   453                                                           math._pow_up(int(prev_vb * PRECISION / vb), wn) / PRECISION
   454                                                       # the `D^n` factor will be updated in `_calc_supply()`
   455                                                       vb_sum_final += dvb
   456                                           
   457                                                       # remove fees from balance and recalculate sum and product
   458                                                       fee = (dvb - prev_vb * lowest /
   459                                                              PRECISION) * fee_rate / PRECISION
   460                                                       vb_prod = vb_prod * \
   461                                                           math._pow_up(int(prev_vb * PRECISION /
   462                                                                        (vb - fee)), wn) / PRECISION
   463                                                       vb_sum += dvb - fee
   464                                                   j = unsafe_add(j, 1)
   465                                           
   466                                               #  check bands
   467                                               j = 0
   468                                               for token in range(MAX_NUM_ASSETS):
   469                                                   if token == num_tokens:
   470                                                       break
   471                                                   if _amounts[token] == 0:
   472                                                       continue
   473                                                   _check_bands(pool.functions.virtualBalance(token).call() * rates[j] / pool.functions.rate(
   474                                                       token).call() * PRECISION / prev_vb_sum, balances[j] * PRECISION / vb_sum_final, packed_weights[token])
   475                                                   j = unsafe_add(j, 1)
   476                                           
   477                                               supply = 0
   478                                               (supply, vb_prod) = _calc_supply(int(num_tokens), int(prev_supply),
   479                                                                                int(amplification), int(vb_prod), int(vb_sum), prev_supply == 0)
   480                                               return supply - prev_supply

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_lp at line 483

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   483                                           @profile
   484                                           def get_remove_lp(_lp_amount: int) -> List[int]:
   485                                               amounts = []
   486                                               num_tokens = pool.functions.numTokens().call()
   487                                               prev_supply = pool.functions.supply().call()
   488                                           
   489                                               assert (_lp_amount <= prev_supply)
   490                                           
   491                                               for token in range(MAX_NUM_ASSETS):
   492                                                   if token == num_tokens:
   493                                                       break
   494                                                   prev_bal = pool.functions.virtualBalance(token).call()
   495                                                   dbal = prev_bal * _lp_amount // prev_supply
   496                                                   amount = dbal * PRECISION // pool.functions.rate(token).call()
   497                                                   amounts.append(amount)
   498                                           
   499                                               return amounts

Total time: 17.8921 s
File: slippage_estimator.py
Function: get_remove_single_lp at line 502

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   502                                           @profile
   503                                           def get_remove_single_lp(_token: int, _lp_amount: int) -> int:
   504         1     697721.0 697721.0      3.9      num_tokens = pool.functions.numTokens().call()
   505         1          0.0      0.0      0.0      assert _token < num_tokens
   506                                           
   507                                               #  update rate
   508         1          1.0      1.0      0.0      prev_supply = 0
   509         1          0.0      0.0      0.0      amplification = 0
   510         1          0.0      0.0      0.0      vb_prod = 0
   511         1          0.0      0.0      0.0      vb_sum = 0
   512         1     701132.0 701132.0      3.9      vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   513         1          1.0      1.0      0.0      packed_weights = []
   514         1          1.0      1.0      0.0      rates = []
   515         2   10638620.0    5e+06     59.5      prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   516         1          4.0      4.0      0.0          unsafe_add(_token, 1), vb_prod, vb_sum)
   517         1          0.0      0.0      0.0      prev_vb_sum = vb_sum
   518                                           
   519         1          0.0      0.0      0.0      supply = prev_supply - _lp_amount
   520         3     693532.0 231177.3      3.9      prev_vb = pool.functions.virtualBalance(_token).call(
   521         2    1391463.0 695731.5      7.8      ) * rates[0] / pool.functions.rate(_token).call()
   522         1          9.0      9.0      0.0      wn = _unpack_wn(packed_weights[_token], num_tokens)
   523                                           
   524                                               #  update variables
   525         1         45.0     45.0      0.0      vb_prod = vb_prod * math._pow_up(int(prev_vb), int(wn)) / PRECISION
   526         5          1.0      0.2      0.0      for i in range(MAX_NUM_ASSETS):
   527         5          0.0      0.0      0.0          if i == num_tokens:
   528         1          0.0      0.0      0.0              break
   529         4          2.0      0.5      0.0          vb_prod = vb_prod * supply / prev_supply
   530         1          0.0      0.0      0.0      vb_sum = vb_sum - prev_vb
   531                                           
   532                                               #  calculate new balance of token
   533         3        195.0     65.0      0.0      vb = _calc_vb(int(wn), int(prev_vb), int(supply), int(
   534         2          0.0      0.0      0.0          amplification), int(vb_prod), int(vb_sum))
   535         1          1.0      1.0      0.0      dvb = prev_vb - vb
   536         1    1065267.0    1e+06      6.0      fee = int(dvb) * pool.functions.swapFeeRate().call() // 2 // PRECISION
   537         1          8.0      8.0      0.0      dvb -= fee
   538         1          2.0      2.0      0.0      vb += fee
   539         1         11.0     11.0      0.0      dx = dvb * PRECISION / rates[0]
   540         1          2.0      2.0      0.0      vb_sum = vb_sum + vb
   541                                           
   542         5         12.0      2.4      0.0      for token in range(MAX_NUM_ASSETS):
   543         5          6.0      1.2      0.0          if token == num_tokens:
   544         1          1.0      1.0      0.0              break
   545         4          1.0      0.2      0.0          if token == _token:
   546         4         17.0      4.2      0.0              _check_bands(prev_vb * PRECISION // prev_vb_sum, vb *
   547         3          1.0      0.3      0.0                           PRECISION // vb_sum, packed_weights[token])
   548                                                   else:
   549         3    2703961.0 901320.3     15.1              bal = pool.functions.virtualBalance(token).call()
   550        12        126.0     10.5      0.0              _check_bands(bal * PRECISION / prev_vb_sum, bal *
   551         9          3.0      0.3      0.0                           PRECISION // vb_sum, packed_weights[token])
   552                                           
   553         1          0.0      0.0      0.0      return dx

Total time: 10.6385 s
File: slippage_estimator.py
Function: _get_rates at line 556

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   556                                           @profile
   557                                           def _get_rates(_tokens: int, _vb_prod: int, _vb_sum: int) -> (int, int, int, int, List[int], List[int]):
   558         1          2.0      2.0      0.0      packed_weights = []
   559         1          0.0      0.0      0.0      rates = []
   560                                           
   561         1          1.0      1.0      0.0      amplification = 0
   562         1          1.0      1.0      0.0      vb_prod = 0
   563         1          0.0      0.0      0.0      vb_sum = _vb_sum
   564         2    2899205.0    1e+06     27.3      amplification, vb_prod, _packed_weights, updated = _get_packed_weights(
   565         1          1.0      1.0      0.0          _vb_prod, _vb_sum)
   566                                           
   567         1     746770.0 746770.0      7.0      num_tokens = pool.functions.numTokens().call()
   568                                           
   569         1          1.0      1.0      0.0      if not updated:
   570         5          8.0      1.6      0.0          for token in range(MAX_NUM_ASSETS):
   571         5          3.0      0.6      0.0              if token == num_tokens:
   572         1          0.0      0.0      0.0                  break
   573         4    2791527.0 697881.8     26.2              packed_weights.append(pool.functions.packedWeight(token).call())
   574                                           
   575         2          5.0      2.5      0.0      for i in range(MAX_NUM_ASSETS):
   576         2          9.0      4.5      0.0          token = (_tokens >> unsafe_mul(8, i)) & 255
   577         2          4.0      2.0      0.0          if token == 0 or token > num_tokens:
   578         1          1.0      1.0      0.0              break
   579         1          1.0      1.0      0.0          token = unsafe_sub(token, 1)
   580         1     696166.0 696166.0      6.5          prev_rate = pool.functions.rate(token).call()
   581                                           
   582         1     698475.0 698475.0      6.6          provider_address = pool.functions.rateProviders(token).call()
   583         2      12680.0   6340.0      0.1          provider = web3.eth.contract(
   584         1          1.0      1.0      0.0              address=provider_address, abi=rate_provider_abi)
   585         3        438.0    146.0      0.0          rate = provider.functions.rate(
   586         2    1411797.0 705898.5     13.3              pool.functions.tokens(token).call()).call()
   587         1          1.0      1.0      0.0          assert rate > 0
   588         1          1.0      1.0      0.0          rates.append(rate)
   589                                           
   590         1          0.0      0.0      0.0          if rate == prev_rate:
   591                                                       continue
   592                                           
   593         1          0.0      0.0      0.0          if prev_rate > 0 and vb_sum > 0:
   594                                                       # factor out old rate and factor in new
   595         1         34.0     34.0      0.0              wn = _unpack_wn(packed_weights[token], num_tokens)
   596         3          3.0      1.0      0.0              vb_prod = vb_prod * \
   597         2         88.0     44.0      0.0                  math._pow_up(int(prev_rate * PRECISION // rate),
   598         2          0.0      0.0      0.0                               wn) / PRECISION
   599                                           
   600         1     691673.0 691673.0      6.5              prev_bal = pool.functions.virtualBalance(token).call()
   601         1          3.0      3.0      0.0              bal = prev_bal * rate // prev_rate
   602         1          2.0      2.0      0.0              vb_sum = vb_sum + bal - prev_bal
   603                                           
   604         1          3.0      3.0      0.0      if not updated and vb_prod == _vb_prod and vb_sum == _vb_sum:
   605                                                   return pool.functions.supply().call(), amplification, vb_prod, vb_sum, packed_weights, rates
   606                                           
   607         1          0.0      0.0      0.0      supply = 0
   608         2        289.0    144.5      0.0      (supply, vb_prod) = _calc_supply(int(num_tokens),
   609         1     689295.0 689295.0      6.5                                       int(pool.functions.supply().call()), int(amplification), int(vb_prod), int(vb_sum), True)
   610         1          1.0      1.0      0.0      return supply, amplification, vb_prod, vb_sum, packed_weights, rates

Total time: 2.89912 s
File: slippage_estimator.py
Function: _get_packed_weights at line 613

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   613                                           @profile
   614                                           def _get_packed_weights(_vb_prod: int, _vb_sum: int) -> (int, int, List[int], bool):
   615         1          2.0      2.0      0.0      packed_weights = []
   616         1     691083.0 691083.0     23.8      span = pool.functions.rampLastTime().call()
   617         1    1267647.0    1e+06     43.7      duration = pool.functions.rampStopTime().call()
   618                                           
   619         1     254497.0 254497.0      8.8      block = web3.eth.get_block('latest')
   620         1          1.0      1.0      0.0      timestamp = block['timestamp']
   621         1          1.0      1.0      0.0      if span == 0 or span > timestamp or (block.timestamp - span < pool.functions.rampStep().call() and duration > timestamp):
   622         1     685884.0 685884.0     23.7          return pool.functions.amplification().call(), _vb_prod, packed_weights, False
   623                                           
   624                                               if timestamp < duration:
   625                                                   # ramp in progress
   626                                                   duration -= span
   627                                               else:
   628                                                   #  ramp has finished
   629                                                   duration = 0
   630                                               span = timestamp - span
   631                                           
   632                                               #  update amplification
   633                                               current = pool.functions.amplification().call()
   634                                               target = pool.functions.targetAmplification().call()
   635                                           
   636                                               if duration == 0:
   637                                                   current = target
   638                                               else:
   639                                                   if current > target:
   640                                                       current = current - (current - target) * span / duration
   641                                                   else:
   642                                                       current = current + (target - current) * span / duration
   643                                               amplification = current
   644                                           
   645                                               #  update weights
   646                                               num_tokens = pool.functions.numTokens.call()
   647                                               supply = pool.functions.supply().call()
   648                                               vb_prod = 0
   649                                               if _vb_sum > 0:
   650                                                   vb_prod = PRECISION
   651                                               lower = 0
   652                                               upper = 0
   653                                               for token in range(MAX_NUM_ASSETS):
   654                                                   if token == num_tokens:
   655                                                       break
   656                                                   current, target, lower, upper = pool.functions.weight(token).call()
   657                                                   if duration == 0:
   658                                                       current = target
   659                                                   else:
   660                                                       if current > target:
   661                                                           current -= (current - target) * span / duration
   662                                                       else:
   663                                                           current += (target - current) * span / duration
   664                                                   packed_weights.append(_pack_weight(current, target, lower, upper))
   665                                                   if _vb_sum > 0:
   666                                                       vb_prod = unsafe_div(unsafe_mul(vb_prod, math._pow_down(unsafe_div(unsafe_mul(
   667                                                           supply, current), pool.functions.virtualBalance(token)), unsafe_mul(current, num_tokens))), PRECISION)
   668                                           
   669                                               return amplification, vb_prod, packed_weights, True

Total time: 0 s
File: slippage_estimator.py
Function: _pack_weight at line 672

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   672                                           @profile
   673                                           def _pack_weight(_weight: int, _target: int, _lower: int, _upper: int) -> int:
   674                                               return unsafe_div(_weight, WEIGHT_SCALE) | (unsafe_div(_target, WEIGHT_SCALE) << -TARGET_WEIGHT_SHIFT) | (unsafe_div(_lower, WEIGHT_SCALE) << -LOWER_BAND_SHIFT) | (unsafe_div(_upper, WEIGHT_SCALE) << -UPPER_BAND_SHIFT)

Total time: 0 s
File: slippage_estimator.py
Function: _unpack_weights at line 677

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   677                                           @profile
   678                                           def _unpack_weights(_packed: int) -> (int, int, int, int):
   679                                               return unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -TARGET_WEIGHT_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)

Total time: 8e-06 s
File: slippage_estimator.py
Function: _unpack_wn at line 682

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   682                                           @profile
   683                                           def _unpack_wn(_packed: int, _num_tokens: int) -> int:
   684         2          8.0      4.0    100.0      return unsafe_mul(unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), _num_tokens)

Total time: 0.000176 s
File: slippage_estimator.py
Function: _calc_supply at line 687

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   687                                           @profile
   688                                           def _calc_supply(_num_tokens: int, _supply: int, _amplification: int, _vb_prod: int, _vb_sum: int, _up: bool) -> (int, int):
   689                                               # s[n+1] = (A sum / w^n - s^(n+1) w^n /prod^n)) / (A w^n - 1)
   690                                               #        = (l - s r) / d
   691                                           
   692         1          1.0      1.0      0.6      l = _amplification
   693         1          3.0      3.0      1.7      d = l - PRECISION
   694         1          0.0      0.0      0.0      s = _supply
   695         1          1.0      1.0      0.6      r = _vb_prod
   696         1          1.0      1.0      0.6      l = l * _vb_sum
   697                                           
   698         1          0.0      0.0      0.0      num_tokens = _num_tokens
   699        11          8.0      0.7      4.5      for _ in range(255):
   700        33         29.0      0.9     16.5          sp = unsafe_div(unsafe_sub(
   701        22         13.0      0.6      7.4              l, unsafe_mul(s, r)), d)  # (l - s * r) / d
   702        55         18.0      0.3     10.2          for i in range(MAX_NUM_ASSETS):
   703        55         15.0      0.3      8.5              if i == num_tokens:
   704        11          3.0      0.3      1.7                  break
   705        44         59.0      1.3     33.5              r = unsafe_div(unsafe_mul(r, sp), s)  # r * sp / s
   706        11          2.0      0.2      1.1          if sp >= s:
   707         6         12.0      2.0      6.8              if (sp - s) * PRECISION / s <= MAX_POW_REL_ERR:
   708         1          0.0      0.0      0.0                  if _up:
   709         1          2.0      2.0      1.1                      sp += sp * MAX_POW_REL_ERR / PRECISION
   710                                                           else:
   711                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   712         1          0.0      0.0      0.0                  return sp, r
   713                                                   else:
   714         5          4.0      0.8      2.3              if (s - sp) * PRECISION / s <= MAX_POW_REL_ERR:
   715                                                           if _up:
   716                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   717                                                           else:
   718                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   719                                                           return sp, r
   720        10          5.0      0.5      2.8          s = sp
   721                                           
   722                                               raise "no convergence"

Total time: 0.000174 s
File: slippage_estimator.py
Function: _calc_vb at line 725

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   725                                           @profile
   726                                           def _calc_vb(_wn, _y, _supply, _amplification, _vb_prod, _vb_sum) -> int:
   727                                               # y = x_j, sum' = sum(x_i, i != j), prod' = prod(x_i^w_i, i != j)
   728                                               # w = product(w_i), v_i = w_i n, f_i = 1/v_i
   729                                               # Iteratively find root of g(y) using Newton's method
   730                                               # g(y) = y^(v_j + 1) + (sum' + (w^n / A - 1) D y^(w_j n) - D^(n+1) w^2n / prod'^n
   731                                               #      = y^(v_j + 1) + b y^(v_j) - c
   732                                               # y[n+1] = y[n] - g(y[n])/g'(y[n])
   733                                               #        = (y[n]^2 + b (1 - f_j) y[n] + c f_j y[n]^(1 - v_j)) / (f_j + 1) y[n] + b)
   734                                           
   735         1          0.0      0.0      0.0      d = _supply
   736         1          0.0      0.0      0.0      b = d * PRECISION // _amplification  # actually b + D
   737         1          1.0      1.0      0.6      c = _vb_prod * b // PRECISION
   738         1          0.0      0.0      0.0      b += _vb_sum
   739         1          1.0      1.0      0.6      f = PRECISION * PRECISION // _wn
   740                                           
   741         1          0.0      0.0      0.0      y = _y
   742         2          0.0      0.0      0.0      for _ in range(255):
   743        10        167.0     16.7     96.0          yp = (y + b + d * f // PRECISION + c * f // math._pow_up(int(y), int(_wn)) -
   744         8          2.0      0.2      1.1                b * f // PRECISION - d) * y // (f * y // PRECISION + y + b - d)
   745         2          0.0      0.0      0.0          if yp >= y:
   746         1          1.0      1.0      0.6              if (yp - y) * PRECISION // y <= MAX_POW_REL_ERR:
   747         1          0.0      0.0      0.0                  yp += yp * MAX_POW_REL_ERR // PRECISION
   748         1          1.0      1.0      0.6                  return yp
   749                                                   else:
   750         1          0.0      0.0      0.0              if (y - yp) * PRECISION // y <= MAX_POW_REL_ERR:
   751                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   752                                                           return yp
   753         1          1.0      1.0      0.6          y = yp
   754                                           
   755                                               raise "no convergence"

Total time: 4.9e-05 s
File: slippage_estimator.py
Function: _check_bands at line 758

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   758                                           @profile
   759                                           def _check_bands(_prev_ratio, _ratio, _packed_weight):
   760         4         12.0      3.0     24.5      weight = unsafe_mul(_packed_weight & WEIGHT_MASK, WEIGHT_SCALE)
   761                                           
   762                                               # lower limit check
   763         8          4.0      0.5      8.2      limit = unsafe_mul(
   764         4          6.0      1.5     12.2          (_packed_weight >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE)
   765         4          3.0      0.8      6.1      if limit > weight:
   766         4          0.0      0.0      0.0          limit = 0
   767                                               else:
   768                                                   limit = unsafe_sub(weight, limit)
   769         4          2.0      0.5      4.1      if _ratio < limit:
   770                                                   assert _ratio > _prev_ratio  # dev: ratio below lower band
   771                                           
   772                                               # upper limit check
   773        12         15.0      1.2     30.6      limit = min(unsafe_add(weight, unsafe_mul(
   774         8          3.0      0.4      6.1          (_packed_weight >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)), PRECISION)
   775         4          4.0      1.0      8.2      if _ratio > limit:
   776                                                   assert _ratio < _prev_ratio  # dev: ratio above upper band

