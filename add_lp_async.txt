result - 98456501147342720
Wrote profile results to slippage_estimator.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: slippage_estimator.py
Function: get_output_token at line 341

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   341                                           @profile
   342                                           def get_output_token(_i: int, _j: int, _dx: int) -> int:
   343                                               num_tokens = pool.functions.numTokens().call()
   344                                               assert _i != _j  # dev: same input and output asset
   345                                               assert _i < num_tokens and _j < num_tokens  # dev: index out of bounds
   346                                               assert _dx > 0  # dev: zero amount
   347                                           
   348                                               # update rates for from and to assets
   349                                               supply = 0
   350                                               amplification = 0
   351                                               vb_prod = 0
   352                                               vb_sum = 0
   353                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   354                                               packed_weights = []
   355                                               rates = []
   356                                               supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   357                                                   unsafe_add(_i, 1) | (unsafe_add(_j, 1) << 8), vb_prod, vb_sum)
   358                                               prev_vb_sum = vb_sum
   359                                           
   360                                               prev_vb_x = pool.functions.virtualBalance(
   361                                                   _i).call() * rates[0] / pool.functions.rate(_i).call()
   362                                               wn_x = _unpack_wn(packed_weights[_i], num_tokens)
   363                                           
   364                                               prev_vb_y = pool.functions.virtualBalance(
   365                                                   _j).call() * rates[1] / pool.functions.rate(_j).call()
   366                                               wn_y = _unpack_wn(packed_weights[_j], num_tokens)
   367                                           
   368                                               dx_fee = _dx * pool.functions.swapFeeRate().call() / PRECISION
   369                                               dvb_x = (_dx - dx_fee) * rates[0] / PRECISION
   370                                               vb_x = prev_vb_x + dvb_x
   371                                           
   372                                               # update x_i and remove x_j from variables
   373                                               vb_prod = vb_prod * math._pow_up(int(prev_vb_y), (wn_y)) / \
   374                                                   math._pow_down(int(vb_x * PRECISION // prev_vb_x), int(wn_x))
   375                                               vb_sum = vb_sum + dvb_x - prev_vb_y
   376                                           
   377                                               # calulate new balance of out token
   378                                               vb_y = _calc_vb(int(wn_y), int(prev_vb_y), int(supply),
   379                                                               int(amplification), int(vb_prod), int(vb_sum))
   380                                               vb_sum += vb_y + dx_fee * rates[0] // PRECISION
   381                                           
   382                                               # check bands
   383                                               _check_bands(prev_vb_x * PRECISION // prev_vb_sum,
   384                                                            vb_x * PRECISION // vb_sum, packed_weights[_i])
   385                                               _check_bands(prev_vb_y * PRECISION // prev_vb_sum,
   386                                                            vb_y * PRECISION // vb_sum, packed_weights[_j])
   387                                           
   388                                               return (prev_vb_y - vb_y) * PRECISION / rates[1]

Total time: 0.029215 s
File: slippage_estimator.py
Function: get_add_lp at line 391

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   391                                           @profile
   392                                           async def get_add_lp(_amounts: List[int]) -> int:
   393                                               # for result in asyncio.as_completed([(pool.functions.numTokens().call())]):
   394                                               #    num_tokens = await result
   395                                           
   396                                               #  num_tokens = await asyncio.to_thread(pool.functions.numTokens().call())
   397         1          0.0      0.0      0.0      num_tokens = 4
   398                                               #  num_tokens = await pool.functions.numTokens().call()
   399         1          0.0      0.0      0.0      assert len(_amounts) == num_tokens
   400                                           
   401         1          0.0      0.0      0.0      vb_prod = 0
   402         1          0.0      0.0      0.0      vb_sum = 0
   403         1       1618.0   1618.0      5.5      vb_prod, vb_sum = await pool.functions.virtualBalanceProdSum().call()
   404                                               #  vb_prod, vb_sum = await asyncio.to_thread(pool.functions.virtualBalanceProdSum().call())
   405         1          1.0      1.0      0.0      assert vb_sum > 0
   406                                           
   407                                               # find lowest relative increase in balance
   408         1          1.0      1.0      0.0      tokens = 0
   409         1          3.0      3.0      0.0      lowest = 2**256 - 1
   410         1          0.0      0.0      0.0      sh = 0
   411         5          3.0      0.6      0.0      for token in range(MAX_NUM_ASSETS):
   412         5          0.0      0.0      0.0          if token == num_tokens:
   413         1          0.0      0.0      0.0              break
   414         4          1.0      0.2      0.0          if _amounts[token] > 0:
   415         1          4.0      4.0      0.0              tokens = tokens | (unsafe_add(token, 1) << sh)
   416         1          0.0      0.0      0.0              sh = unsafe_add(sh, 8)
   417         1          0.0      0.0      0.0              if vb_sum > 0 and lowest > 0:
   418         3       3173.0   1057.7     10.9                  lowest = min(_amounts[token] * (await pool.functions.rate(token).call()) /
   419         2       2570.0   1285.0      8.8                               (await pool.functions.virtualBalance(token).call()), lowest)
   420                                                   else:
   421         3          1.0      0.3      0.0              lowest = 0
   422         1          0.0      0.0      0.0      assert (sh > 0)
   423                                           
   424                                               # update rates
   425         1          1.0      1.0      0.0      prev_supply = 0
   426         1          0.0      0.0      0.0      amplification = 0
   427         1          1.0      1.0      0.0      packed_weights = []
   428         1          0.0      0.0      0.0      rates = []
   429                                           
   430         2       2607.0   1303.5      8.9      prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = await _get_rates(
   431         1          0.0      0.0      0.0          tokens, vb_prod, vb_sum)
   432                                           
   433         1          1.0      1.0      0.0      vb_prod_final = vb_prod
   434         1          1.0      1.0      0.0      vb_sum_final = vb_sum
   435                                               # fee_rate = int((await pool.functions.swapFeeRate().call()) / 2)
   436         1          3.0      3.0      0.0      fee_rate = int(150000000000000)
   437         1          0.0      0.0      0.0      prev_vb_sum = vb_sum
   438         1          0.0      0.0      0.0      balances = []
   439         1          1.0      1.0      0.0      j = 0
   440         5          6.0      1.2      0.0      for token in range(MAX_NUM_ASSETS):
   441         5          0.0      0.0      0.0          if token == num_tokens:
   442         1          1.0      1.0      0.0              break
   443                                           
   444         4          6.0      1.5      0.0          amount = _amounts[token]
   445         4          4.0      1.0      0.0          if amount == 0:
   446         3          2.0      0.7      0.0              continue
   447                                           
   448         5       6059.0   1211.8     20.7          prev_vb = (await pool.functions.virtualBalance(
   449         4       3351.0    837.8     11.5              token).call()) * rates[j] / (await pool.functions.rate(token).call())
   450                                           
   451         1          4.0      4.0      0.0          dvb = amount * rates[j] / PRECISION
   452         1          1.0      1.0      0.0          vb = prev_vb + dvb
   453         1          1.0      1.0      0.0          balances.append(vb)
   454                                           
   455         1          1.0      1.0      0.0          if prev_supply > 0:
   456         1         24.0     24.0      0.1              wn = _unpack_wn(packed_weights[token], num_tokens)
   457                                           
   458                                                       # update product and sum of virtual balances
   459         3          3.0      1.0      0.0              vb_prod_final = vb_prod_final * \
   460         2        189.0     94.5      0.6                  math._pow_up(int(prev_vb * PRECISION / vb), wn) / PRECISION
   461                                                       # the `D^n` factor will be updated in `_calc_supply()`
   462         1          1.0      1.0      0.0              vb_sum_final += dvb
   463                                           
   464                                                       # remove fees from balance and recalculate sum and product
   465         4          3.0      0.8      0.0              fee = (dvb - prev_vb * lowest /
   466         3          1.0      0.3      0.0                     PRECISION) * fee_rate / PRECISION
   467         3          3.0      1.0      0.0              vb_prod = vb_prod * \
   468         3        153.0     51.0      0.5                  math._pow_up(int(prev_vb * PRECISION /
   469         3          3.0      1.0      0.0                               (vb - fee)), wn) / PRECISION
   470         1          1.0      1.0      0.0              vb_sum += dvb - fee
   471         1          2.0      2.0      0.0          j = unsafe_add(j, 1)
   472                                           
   473                                               #  check bands
   474         1          1.0      1.0      0.0      j = 0
   475         5          6.0      1.2      0.0      for token in range(MAX_NUM_ASSETS):
   476         5          4.0      0.8      0.0          if token == num_tokens:
   477         1          0.0      0.0      0.0              break
   478         4          4.0      1.0      0.0          if _amounts[token] == 0:
   479         3          2.0      0.7      0.0              continue
   480         6       8656.0   1442.7     29.6          _check_bands((await pool.functions.virtualBalance(token).call()) * rates[j] / (await pool.functions.rate(
   481         5         16.0      3.2      0.1              token).call()) * PRECISION / prev_vb_sum, balances[j] * PRECISION / vb_sum_final, packed_weights[token])
   482         1          4.0      4.0      0.0          j = unsafe_add(j, 1)
   483                                           
   484         1          1.0      1.0      0.0      supply = 0
   485         2        708.0    354.0      2.4      (supply, vb_prod) = _calc_supply(int(num_tokens), int(prev_supply),
   486         1          3.0      3.0      0.0                                       int(amplification), int(vb_prod), int(vb_sum), prev_supply == 0)
   487         1          1.0      1.0      0.0      return supply - prev_supply

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_lp at line 490

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   490                                           @ profile
   491                                           def get_remove_lp(_lp_amount: int) -> List[int]:
   492                                               amounts = []
   493                                               num_tokens = pool.functions.numTokens().call()
   494                                               prev_supply = pool.functions.supply().call()
   495                                           
   496                                               assert (_lp_amount <= prev_supply)
   497                                           
   498                                               for token in range(MAX_NUM_ASSETS):
   499                                                   if token == num_tokens:
   500                                                       break
   501                                                   prev_bal = pool.functions.virtualBalance(token).call()
   502                                                   dbal = prev_bal * _lp_amount // prev_supply
   503                                                   amount = dbal * PRECISION // pool.functions.rate(token).call()
   504                                                   amounts.append(amount)
   505                                           
   506                                               return amounts

Total time: 0 s
File: slippage_estimator.py
Function: get_remove_single_lp at line 509

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   509                                           @ profile
   510                                           def get_remove_single_lp(_token: int, _lp_amount: int) -> int:
   511                                               num_tokens = pool.functions.numTokens().call()
   512                                               assert _token < num_tokens
   513                                           
   514                                               #  update rate
   515                                               prev_supply = 0
   516                                               amplification = 0
   517                                               vb_prod = 0
   518                                               vb_sum = 0
   519                                               vb_prod, vb_sum = pool.functions.virtualBalanceProdSum().call()
   520                                               packed_weights = []
   521                                               rates = []
   522                                               prev_supply, amplification, vb_prod, vb_sum, packed_weights, rates = _get_rates(
   523                                                   unsafe_add(_token, 1), vb_prod, vb_sum)
   524                                               prev_vb_sum = vb_sum
   525                                           
   526                                               supply = prev_supply - _lp_amount
   527                                               prev_vb = pool.functions.virtualBalance(_token).call(
   528                                               ) * rates[0] / pool.functions.rate(_token).call()
   529                                               wn = _unpack_wn(packed_weights[_token], num_tokens)
   530                                           
   531                                               #  update variables
   532                                               vb_prod = vb_prod * math._pow_up(int(prev_vb), int(wn)) / PRECISION
   533                                               for i in range(MAX_NUM_ASSETS):
   534                                                   if i == num_tokens:
   535                                                       break
   536                                                   vb_prod = vb_prod * supply / prev_supply
   537                                               vb_sum = vb_sum - prev_vb
   538                                           
   539                                               #  calculate new balance of token
   540                                               vb = _calc_vb(int(wn), int(prev_vb), int(supply), int(
   541                                                   amplification), int(vb_prod), int(vb_sum))
   542                                               dvb = prev_vb - vb
   543                                               fee = int(dvb) * pool.functions.swapFeeRate().call() // 2 // PRECISION
   544                                               dvb -= fee
   545                                               vb += fee
   546                                               dx = dvb * PRECISION / rates[0]
   547                                               vb_sum = vb_sum + vb
   548                                           
   549                                               for token in range(MAX_NUM_ASSETS):
   550                                                   if token == num_tokens:
   551                                                       break
   552                                                   if token == _token:
   553                                                       _check_bands(prev_vb * PRECISION // prev_vb_sum, vb *
   554                                                                    PRECISION // vb_sum, packed_weights[token])
   555                                                   else:
   556                                                       bal = pool.functions.virtualBalance(token).call()
   557                                                       _check_bands(bal * PRECISION / prev_vb_sum, bal *
   558                                                                    PRECISION // vb_sum, packed_weights[token])
   559                                           
   560                                               return dx

Total time: 0.044371 s
File: slippage_estimator.py
Function: _get_rates at line 563

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   563                                           @ profile
   564                                           async def _get_rates(_tokens: int, _vb_prod: int, _vb_sum: int) -> (int, int, int, int, List[int], List[int]):
   565         1          0.0      0.0      0.0      packed_weights = []
   566         1          0.0      0.0      0.0      rates = []
   567                                           
   568         1          0.0      0.0      0.0      amplification = 0
   569         1          0.0      0.0      0.0      vb_prod = 0
   570         1          0.0      0.0      0.0      vb_sum = _vb_sum
   571         2       2571.0   1285.5      5.8      amplification, vb_prod, _packed_weights, updated = await _get_packed_weights(
   572         1          0.0      0.0      0.0          _vb_prod, _vb_sum)
   573                                           
   574                                               # num_tokens = pool.functions.numTokens().call()
   575         1          2.0      2.0      0.0      num_tokens = 4
   576                                           
   577         1          0.0      0.0      0.0      if not updated:
   578         5          7.0      1.4      0.0          for token in range(MAX_NUM_ASSETS):
   579         5          2.0      0.4      0.0              if token == num_tokens:
   580         1          1.0      1.0      0.0                  break
   581         4      12623.0   3155.8     28.4              packed_weight = await pool.functions.packedWeight(token).call()
   582         4         14.0      3.5      0.0              packed_weights.append(packed_weight)
   583                                           
   584         2          4.0      2.0      0.0      for i in range(MAX_NUM_ASSETS):
   585         2         15.0      7.5      0.0          token = (_tokens >> unsafe_mul(8, i)) & 255
   586         2          2.0      1.0      0.0          if token == 0 or token > num_tokens:
   587         1          2.0      2.0      0.0              break
   588         1          1.0      1.0      0.0          token = unsafe_sub(token, 1)
   589         1       2100.0   2100.0      4.7          prev_rate = await pool.functions.rate(token).call()
   590                                           
   591         1       6149.0   6149.0     13.9          provider_address = await pool.functions.rateProviders(token).call()
   592         2       1420.0    710.0      3.2          provider = web3.eth.contract(
   593         1          2.0      2.0      0.0              address=provider_address, abi=rate_provider_abi)
   594         3       7017.0   2339.0     15.8          rate = await provider.functions.rate(
   595         2       4456.0   2228.0     10.0              await pool.functions.tokens(token).call()).call()
   596         1          4.0      4.0      0.0          assert rate > 0
   597         1          2.0      2.0      0.0          rates.append(rate)
   598                                           
   599         1          1.0      1.0      0.0          if rate == prev_rate:
   600                                                       continue
   601                                           
   602         1          1.0      1.0      0.0          if prev_rate > 0 and vb_sum > 0:
   603                                                       # factor out old rate and factor in new
   604         1         54.0     54.0      0.1              wn = _unpack_wn(packed_weights[token], num_tokens)
   605         3          8.0      2.7      0.0              vb_prod = vb_prod * \
   606         2        286.0    143.0      0.6                  math._pow_up(int(prev_rate * PRECISION // rate),
   607         2          0.0      0.0      0.0                               wn) / PRECISION
   608                                           
   609         1       3134.0   3134.0      7.1              prev_bal = await pool.functions.virtualBalance(token).call()
   610         1          8.0      8.0      0.0              bal = prev_bal * rate // prev_rate
   611         1          6.0      6.0      0.0              vb_sum = vb_sum + bal - prev_bal
   612                                           
   613         1          7.0      7.0      0.0      if not updated and vb_prod == _vb_prod and vb_sum == _vb_sum:
   614                                                   return (await pool.functions.supply().call()), amplification, vb_prod, vb_sum, packed_weights, rates
   615                                           
   616         1          0.0      0.0      0.0      supply = 0
   617         2        460.0    230.0      1.0      (supply, vb_prod) = _calc_supply(int(num_tokens),
   618         1       4009.0   4009.0      9.0                                       int(await pool.functions.supply().call()), int(amplification), int(vb_prod), int(vb_sum), True)
   619         1          3.0      3.0      0.0      return supply, amplification, vb_prod, vb_sum, packed_weights, rates

Total time: 0.007555 s
File: slippage_estimator.py
Function: _get_packed_weights at line 622

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   622                                           @ profile
   623                                           async def _get_packed_weights(_vb_prod: int, _vb_sum: int) -> (int, int, List[int], bool):
   624         1          1.0      1.0      0.0      packed_weights = []
   625         1       2561.0   2561.0     33.9      span = await pool.functions.rampLastTime().call()
   626         1       2428.0   2428.0     32.1      duration = await pool.functions.rampStopTime().call()
   627                                           
   628         1        510.0    510.0      6.8      block = await web3.eth.get_block('latest')
   629         1          3.0      3.0      0.0      timestamp = block['timestamp']
   630         1          0.0      0.0      0.0      if span == 0 or span > timestamp or (block.timestamp - span < (await pool.functions.rampStep().call()) and duration > timestamp):
   631         1       2052.0   2052.0     27.2          return (await pool.functions.amplification().call()), _vb_prod, packed_weights, False
   632                                           
   633                                               if timestamp < duration:
   634                                                   # ramp in progress
   635                                                   duration -= span
   636                                               else:
   637                                                   #  ramp has finished
   638                                                   duration = 0
   639                                               span = timestamp - span
   640                                           
   641                                               #  update amplification
   642                                               current = await pool.functions.amplification().call()
   643                                               target = await pool.functions.targetAmplification().call()
   644                                           
   645                                               if duration == 0:
   646                                                   current = target
   647                                               else:
   648                                                   if current > target:
   649                                                       current = current - (current - target) * span / duration
   650                                                   else:
   651                                                       current = current + (target - current) * span / duration
   652                                               amplification = current
   653                                           
   654                                               #  update weights
   655                                               #  num_tokens = pool.functions.numTokens.call()
   656                                               num_tokens = 4
   657                                               supply = await pool.functions.supply().call()
   658                                               vb_prod = 0
   659                                               if _vb_sum > 0:
   660                                                   vb_prod = PRECISION
   661                                               lower = 0
   662                                               upper = 0
   663                                               for token in range(MAX_NUM_ASSETS):
   664                                                   if token == num_tokens:
   665                                                       break
   666                                                   current, target, lower, upper = (await pool.functions.weight(token).call())
   667                                                   if duration == 0:
   668                                                       current = target
   669                                                   else:
   670                                                       if current > target:
   671                                                           current -= (current - target) * span / duration
   672                                                       else:
   673                                                           current += (target - current) * span / duration
   674                                                   packed_weights.append(_pack_weight(current, target, lower, upper))
   675                                                   if _vb_sum > 0:
   676                                                       vb_prod = unsafe_div(unsafe_mul(vb_prod, math._pow_down(unsafe_div(unsafe_mul(
   677                                                           supply, current), (await pool.functions.virtualBalance(token))), unsafe_mul(current, num_tokens))), PRECISION)
   678                                           
   679                                               return amplification, vb_prod, packed_weights, True

Total time: 0 s
File: slippage_estimator.py
Function: _pack_weight at line 682

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   682                                           @ profile
   683                                           def _pack_weight(_weight: int, _target: int, _lower: int, _upper: int) -> int:
   684                                               return unsafe_div(_weight, WEIGHT_SCALE) | (unsafe_div(_target, WEIGHT_SCALE) << -TARGET_WEIGHT_SHIFT) | (unsafe_div(_lower, WEIGHT_SCALE) << -LOWER_BAND_SHIFT) | (unsafe_div(_upper, WEIGHT_SCALE) << -UPPER_BAND_SHIFT)

Total time: 0 s
File: slippage_estimator.py
Function: _unpack_weights at line 687

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   687                                           @ profile
   688                                           def _unpack_weights(_packed: int) -> (int, int, int, int):
   689                                               return unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -TARGET_WEIGHT_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE), unsafe_mul((_packed >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)

Total time: 2e-05 s
File: slippage_estimator.py
Function: _unpack_wn at line 692

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   692                                           @ profile
   693                                           def _unpack_wn(_packed: int, _num_tokens: int) -> int:
   694         2         20.0     10.0    100.0      return unsafe_mul(unsafe_mul(_packed & WEIGHT_MASK, WEIGHT_SCALE), _num_tokens)

Total time: 0.000673 s
File: slippage_estimator.py
Function: _calc_supply at line 697

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   697                                           @ profile
   698                                           def _calc_supply(_num_tokens: int, _supply: int, _amplification: int, _vb_prod: int, _vb_sum: int, _up: bool) -> (int, int):
   699                                               # s[n+1] = (A sum / w^n - s^(n+1) w^n /prod^n)) / (A w^n - 1)
   700                                               #        = (l - s r) / d
   701                                           
   702         2          1.0      0.5      0.1      l = _amplification
   703         2          6.0      3.0      0.9      d = l - PRECISION
   704         2          1.0      0.5      0.1      s = _supply
   705         2          0.0      0.0      0.0      r = _vb_prod
   706         2          3.0      1.5      0.4      l = l * _vb_sum
   707                                           
   708         2          0.0      0.0      0.0      num_tokens = _num_tokens
   709        23         17.0      0.7      2.5      for _ in range(255):
   710        69         92.0      1.3     13.7          sp = unsafe_div(unsafe_sub(
   711        46         48.0      1.0      7.1              l, unsafe_mul(s, r)), d)  # (l - s * r) / d
   712       115         76.0      0.7     11.3          for i in range(MAX_NUM_ASSETS):
   713       115         73.0      0.6     10.8              if i == num_tokens:
   714        23         11.0      0.5      1.6                  break
   715        92        244.0      2.7     36.3              r = unsafe_div(unsafe_mul(r, sp), s)  # r * sp / s
   716        23         15.0      0.7      2.2          if sp >= s:
   717        12         33.0      2.8      4.9              if (sp - s) * PRECISION / s <= MAX_POW_REL_ERR:
   718         1          0.0      0.0      0.0                  if _up:
   719                                                               sp += sp * MAX_POW_REL_ERR / PRECISION
   720                                                           else:
   721         1          3.0      3.0      0.4                      sp -= sp * MAX_POW_REL_ERR / PRECISION
   722         1          1.0      1.0      0.1                  return sp, r
   723                                                   else:
   724        11         24.0      2.2      3.6              if (s - sp) * PRECISION / s <= MAX_POW_REL_ERR:
   725         1          0.0      0.0      0.0                  if _up:
   726         1          5.0      5.0      0.7                      sp += sp * MAX_POW_REL_ERR / PRECISION
   727                                                           else:
   728                                                               sp -= sp * MAX_POW_REL_ERR / PRECISION
   729         1          0.0      0.0      0.0                  return sp, r
   730        21         20.0      1.0      3.0          s = sp
   731                                           
   732                                               raise "no convergence"

Total time: 0 s
File: slippage_estimator.py
Function: _calc_vb at line 735

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   735                                           @ profile
   736                                           def _calc_vb(_wn, _y, _supply, _amplification, _vb_prod, _vb_sum) -> int:
   737                                               # y = x_j, sum' = sum(x_i, i != j), prod' = prod(x_i^w_i, i != j)
   738                                               # w = product(w_i), v_i = w_i n, f_i = 1/v_i
   739                                               # Iteratively find root of g(y) using Newton's method
   740                                               # g(y) = y^(v_j + 1) + (sum' + (w^n / A - 1) D y^(w_j n) - D^(n+1) w^2n / prod'^n
   741                                               #      = y^(v_j + 1) + b y^(v_j) - c
   742                                               # y[n+1] = y[n] - g(y[n])/g'(y[n])
   743                                               #        = (y[n]^2 + b (1 - f_j) y[n] + c f_j y[n]^(1 - v_j)) / (f_j + 1) y[n] + b)
   744                                           
   745                                               d = _supply
   746                                               b = d * PRECISION // _amplification  # actually b + D
   747                                               c = _vb_prod * b // PRECISION
   748                                               b += _vb_sum
   749                                               f = PRECISION * PRECISION // _wn
   750                                           
   751                                               y = _y
   752                                               for _ in range(255):
   753                                                   yp = (y + b + d * f // PRECISION + c * f // math._pow_up(int(y), int(_wn)) -
   754                                                         b * f // PRECISION - d) * y // (f * y // PRECISION + y + b - d)
   755                                                   if yp >= y:
   756                                                       if (yp - y) * PRECISION // y <= MAX_POW_REL_ERR:
   757                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   758                                                           return yp
   759                                                   else:
   760                                                       if (y - yp) * PRECISION // y <= MAX_POW_REL_ERR:
   761                                                           yp += yp * MAX_POW_REL_ERR // PRECISION
   762                                                           return yp
   763                                                   y = yp
   764                                           
   765                                               raise "no convergence"

Total time: 3.9e-05 s
File: slippage_estimator.py
Function: _check_bands at line 768

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   768                                           @ profile
   769                                           def _check_bands(_prev_ratio, _ratio, _packed_weight):
   770         1         11.0     11.0     28.2      weight = unsafe_mul(_packed_weight & WEIGHT_MASK, WEIGHT_SCALE)
   771                                           
   772                                               # lower limit check
   773         2          1.0      0.5      2.6      limit = unsafe_mul(
   774         1          5.0      5.0     12.8          (_packed_weight >> -LOWER_BAND_SHIFT) & WEIGHT_MASK, WEIGHT_SCALE)
   775         1          1.0      1.0      2.6      if limit > weight:
   776         1          1.0      1.0      2.6          limit = 0
   777                                               else:
   778                                                   limit = unsafe_sub(weight, limit)
   779         1          1.0      1.0      2.6      if _ratio < limit:
   780                                                   assert _ratio > _prev_ratio  # dev: ratio below lower band
   781                                           
   782                                               # upper limit check
   783         3         12.0      4.0     30.8      limit = min(unsafe_add(weight, unsafe_mul(
   784         2          2.0      1.0      5.1          (_packed_weight >> -UPPER_BAND_SHIFT), WEIGHT_SCALE)), PRECISION)
   785         1          5.0      5.0     12.8      if _ratio > limit:
   786                                                   assert _ratio < _prev_ratio  # dev: ratio above upper band

